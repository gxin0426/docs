## hw

#### 1.字符串最后一个单词的长度 

~~~go
package main
import(
    "fmt"
    "strings"
    "bufio"
    "os"
)
func main(){   
        reader := bufio.NewReader(os.Stdin)
        data, _, _ := reader.ReadLine()
        str := string(data)
    a := countLastStr(str)
    fmt.Println(a)
}
func countLastStr(str string) int {
    strs := strings.Fields(str)
    endStr := strs[len(strs) - 1]
    return len(endStr)
}
~~~

#### 2.计算字符个数 

~~~go
package main
import (
    "fmt"
    "strings"
)
var(
    inputStr string
    aWord string
)
func main(){   
    fmt.Scanln(&inputStr)
    fmt.Scanln(&aWord)
    inputStr = strings.ToLower(inputStr)
	b := []byte(inputStr)
	b2 := []byte(aWord)
    res := 0
    for i := 0; i < len(b); i ++ {

       if  b[i] == b2[0] {
		res ++
	   }
    }
    fmt.Println(res)     
}
~~~

#### 3.字符串分割

~~~go
package main
import (
	"fmt"
)
func main(){
	var inputStr1 string
    var inputStr2 string
    _, err := fmt.Scan(&inputStr1)
    if err != nil{
        return
    }
    fmt.Scan(&inputStr2)   
    comF(inputStr1)
    comF(inputStr2)
}
func comF(s string){
    for len(s) > 8 {
        fmt.Println(s[:8])
        s = s[8:]
    }
    arr := make([]byte, 0)
    for j := 0; j < 8 -len(s); j++{
        arr = append(arr, '0')
    }
    s += string(arr)
    fmt.Println(s)
}

//第二种
package main
import "fmt"
func main(){
    
	var num int
	var inputStr string
    for{
    _, err := fmt.Scanln(&num)
    if err != nil {
		return
    }
    for i := 0; i < num; i++{
        fmt.Scanln(&inputStr)
        //fmt.Println(inputStr)
        comF(inputStr)
	}
    }
}
func comF(str string){
    for len(str) > 8 {
        fmt.Println(str[:8])
        str = str[8:]
    }
    
    arr := make([]byte, 0)
    for i := 0; i < 8 -len(str); i++{
        arr = append(arr, '0')
    }
    str += string(arr)
    fmt.Println(str)
}
~~~

#### 4.进制转换

~~~go
package main
import "fmt"
func main(){
    var n int
    for {      
        _, err := fmt.Scanf("0x%x",&n)
        if err != nil{
            return
        }
        fmt.Println(n)
    }
}
~~~

#### 5.质数因子

~~~go
package main
import (
	"fmt"
)
func main(){
    var i int64
    var n int64
    for{
        _, err := fmt.Scan(&n)
        if err != nil{
            break
        } 
        i = 2
        for n != 1 {
            if n % i == 0{
                fmt.Printf("%d ", i)
                n = n / i
            }else {
                i++
            }
        }
    }
}
~~~

#### 6.取近似值

~~~go
package main
import (
	"fmt"
	"strconv"
	"strings"
)
func main(){
    var a float64
    for{    
        _, err := fmt.Scan(&a)
        if err !=nil{
            break
        }        
	fmt.Println(commonF(a))
    }
}
func commonF(f float64) int {
	str := strconv.FormatFloat(f, 'G', -1, 32)
	p := strings.Split(str, ".")
	num, _ := strconv.Atoi(p[0])
	num1, _ := strconv.Atoi(p[1])
	if num1 >= 5 {
		num++
		return num
	}else{
		return num
	}	
}
~~~

#### 7.合并表记录

~~~go
package main
import (
	"fmt"
    "sort"
)
func main(){
    var(
        n int
        k int
        v int
    )
    for {
        _, err := fmt.Scan(&n)
        if err != nil{
            return
        }
        m := make(map[int]int, n)
        
        for i := 0; i < n; i++{
            fmt.Scan(&k, &v)
            
            if m[k] != 0{
                m[k] = m[k] + v
            }else{
                m[k] = v
            }
        }
        keys := make([]int, 0)
        
        for k := range m {
            keys = append(keys, k)
        }
        sort.Ints(keys)
        for _, k := range keys{
            fmt.Println(k, m[k])
        }       
    } 
}
~~~

#### 8. 明明的随机数

~~~go
package main
import (
	"fmt"
	"math/rand"
	"sort"

)
func main(){
	var inputNum int
	a := make([]int, 0)
	fmt.Println("please enter a num")
	fmt.Scanln(&inputNum)
	for i := 0; i < inputNum; i++ {
		a = append(a, rand.Intn(1000))
	}
	fmt.Println(a)
	sort.Ints(a)
	fmt.Println(a)
	//去重
	b := make([]int, 0)
	for i := 0; i < len(a); i++{
		repeat := false
		for j := i + 1; j < len(a); j++{
			if a[i] == a[j]{
				repeat = true
				break
			}
		}
		if !repeat{
			b = append(b, a[i])
		}
	}
	fmt.Println(b)
}
~~~

#### 9. 提取不重复的整数

~~~go
package main
import "fmt"
func main(){
    for {
    var input int
        _, err := fmt.Scan(&input)
        if err != nil{
            return
        }
        m := make(map[int]bool, 0)
        for input > 0 {
            temp := input % 10
            input = input / 10
            if m[temp] == false{
                fmt.Print(temp)
                m[temp] = true
            }
        }
    }
}
~~~

#### 10. 字符个数计算

~~~go
package main
import(
	"fmt"
)
func main(){
	var inputStr string
	fmt.Scan(&inputStr)
    b := []byte(inputStr)
    m := make(map[byte]bool, 0)
    count := 0
    for _, v := range b {
        if _, ok := m[v]; !ok{
            count++
            m[v] = true
        }
    }  
	fmt.Println(count)
}
~~~

#### 11.数字颠倒

~~~go
package main
import(
	"fmt"
)
func main(){
	var input string
    fmt.Scan(&input)
    b := []byte(input)
    var str2 string
    for i := 0; i < len(b); i++{
        str2 += string(b[len(b) - 1 - i])
    }
    fmt.Println(str2)
}
~~~

#### 12.字符串反正

~~~go
package main
import(
	"fmt"
)
func main(){
	var inputStr string
	//fmt.Println("enter a string")
	fmt.Scanln(&inputStr)
	b := []byte(inputStr)
	//fmt.Println(b)
	for i := 0; i < len(b); i++{
		fmt.Print(string(b[len(b) - i -1]))
	}
}
~~~

#### 13.句子逆序

~~~go
package main
import(
	"fmt"
	"strings"
	"os"
	"bufio"
)
func main(){
	//var inputStr string
	//fmt.Println("enter a string")
	reader := bufio.NewReader(os.Stdin)
	data, _, _ := reader.ReadLine()
	//fmt.Println(string(data))
	// fmt.Scan(&inputStr)
	// fmt.Println(inputStr)
	b := strings.Fields(string(data))
	for i := 0; i < len(b); i++{
		fmt.Print(b[len(b) - 1 - i], " ")
	}
}
~~~

#### 14. 字串的连接最长路径查找 

~~~go
package main
import(
    "fmt"
    "sort"
)
func main(){
    var input int
    fmt.Scan(&input)
    var inputStr string
    s := make([]string, 0)
    for i := 0; i < input; i++{
        fmt.Scan(&inputStr)
        s = append(s, inputStr)
    }
    sort.Strings(s)
    for _, v := range s{
        fmt.Println(v)
    }
}
~~~



#### 15. 求int型正整数在内存中存储时1的个数 

~~~go
package main
import(
	"fmt"
)
func main(){
	var inputInt int
	fmt.Scanln(&inputInt)
	count := 0
	for {
		res := 0
		res = inputInt % 2
		inputInt = inputInt / 2
		if res == 1 {
			count++
		}
		if inputInt == 0{
			break
		}
	}
	fmt.Println(count)
}
~~~

#### 16.购物单

#### 17.坐标移动

~~~go
package main
import(
	"fmt"
	"strings"
	_"os"
	_"bufio"
	"strconv"
)
func main(){
	var x int
	var y int
	fmt.Println("enter a string")
	var inputStr string
	fmt.Scanln(&inputStr)
	strSlice := strings.Split(inputStr, ";")
	//fmt.Println(strSlice)
	for i := 0; i < len(strSlice); i++{
		b := []byte(strSlice[i])
		//fmt.Println(b[0])
		var midStr string
		for i := 1; i < len(b); i++{
			midStr = midStr + string(b[i])
		}
		midNum, _ := strconv.Atoi(midStr)
		if string(b[0]) == "A"{
			x = x + midNum
		}else if string(b[0]) == "D"{
			x = x - midNum
		}else if string(b[0]) == "W"{
			y = y + midNum
		} else{
			y = y - midNum
		}
		
	}
	fmt.Println(x,y)
}
~~~

#### 18.最小公倍数

~~~go
package main 
import(
    "fmt"
)
func main(){
    var x int
    var y int
    fmt.Scanf("%d %d", &x, &y)
    fmt.Println(commonF(x,y))
}
func commonF(x, y int) int {
    max := x * y
    i := 0
    if x > y {
        i = x
    }else{
        i = y
    }
    
    for ; x < max; i++{
        if i % x == 0 && i % y == 0{
            return i
        }
    }
    return max
}
~~~

#### 19.最大公约数

~~~go
package main 

import(
    "fmt"
)
func main(){
    var x int
    var y int
	fmt.Scanf("%d %d", &x, &y)
    fmt.Println(commonF(x,y))  
}
func commonF(x, y int) int {
	var n int
    if x < y {
        n = x
    }else{
		n = y
	}
    for i := n ; i >= 1; i-- {
        if x % i == 0 && y % i ==0 {
            return i
        }
    }
    return 1
}
~~~

#### 19-2 求解立方根

~~~go
package main
import(
	"fmt"
	_"io"
	"math"
)
func main(){
	var inputF float64
	fmt.Scan(&inputF)
	x := 1.0
	for {
		if math.Abs(x*x*x - inputF) < 0.0001{
			break
		}
		x = 2*x/3 + inputF/3/x/x
		
	}
	fmt.Printf("%.1f", x)
}
~~~

#### 19-3.记负均正

~~~go
package main
import "fmt"
func main(){
    var input int
    count := 0
    count2 := 0
	sum := 0.0
	for {
	_, err := fmt.Scan(&input)
	if err != nil{
        fmt.Println(count)
		fmt.Printf("%.1f", sum / float64(count2))
		return
	}
    if input < 0 {
        count++
    }else if input > 0{
        count2++
        sum += float64(input)
    }	
}
}
~~~

#### 20.字符逆序

~~~go
package main 
import (
    "fmt"
    "os"
    "bufio"
)
func main(){
    reader := bufio.NewReader(os.Stdin)
    data, _, _ := reader.ReadLine()
    
    for i := 0; i < len(data); i++{
        fmt.Print(string(data[len(data) - 1 - i]))
    }
}
~~~

#### 21.按assii排序输出

~~~go
package main 
import (
    "fmt"
   _ "os"
   _ "bufio"
   _ "strings"
    _"strconv"
    _"encoding/binary"
    "sort"
)
func main(){

    var inputStr string
    fmt.Scanln(&inputStr) 
    b := []byte(inputStr)
//    fmt.Println(b)
    //去重
    midSlice := make([]byte, 0)
	for i := 0; i < len(b); i++{
		repeat := false
		for j := i + 1; j < len(b); j++{
			if b[i] == b[j] {
				repeat = true
				break
		}

    }
    if !repeat {
        midSlice = append(midSlice, b[i])
    }
    }
    midSlice2 := make([]string, len(midSlice))
    for i := 0; i < len(midSlice); i++{
        midSlice2[i] = string(midSlice[i])
    }
    sort.Strings(midSlice2)
    for i := 0; i < len(midSlice2); i++{
        fmt.Print(midSlice2[len(midSlice2) - i - 1])
    }
}
~~~

#### 22. 输入整型数组和排序标识，对其元素按照升序或降序进行排序

~~~go
package main 
import (

    "fmt"
    "sort"
)
func main(){
    var inputInt int
    var jud int
    for{
    _, err := fmt.Scan(&inputInt)
    
    if err != nil{
        break
    }
    var inputIntSlice int
    bSlice := make([]int, inputInt)
    for i := 0; i < inputInt; i++{
        fmt.Scan(&inputIntSlice)
        bSlice[i] = inputIntSlice
    }
    sort.Ints(bSlice)
    
    fmt.Scan(&jud)
    if jud == 0 {
        for i := 0; i < len(bSlice); i++{
            fmt.Printf("%d ", bSlice[i])
        }
    }else {
        for i := 0; i < len(bSlice); i++{
            fmt.Printf("%d ", bSlice[len(bSlice) - 1 - i])
        }
    }
        fmt.Println()
    }
}
~~~

#### 23. 等差数列 

~~~go
package main 
import (
    "fmt"
)
func main(){   
    var inputInt int
    for{
        _, err := fmt.Scan(&inputInt)
        if err != nil {
            break
        }
    b := make([]int64, inputInt)
    for i := 0; i < inputInt; i++{
        if i == 0{
            b[0] = 2
        } else{
            b[i] = b[i - 1] + int64(3)
        }
    }
    var sum int64
    sum = 0
    for i := 0; i < len(b); i++{
        sum = sum + b[i]
    }
    fmt.Println(sum)
    }
}
~~~

#### 24.自守数

~~~go
package main
import (
    "fmt"
)
func main(){
   var input int
    for {
        _, err := fmt.Scan(&input)
        if err != nil {
            break
		}
		count := 1
        for i := 1; i <= input; i++{
            count += comf(i)
		}
		fmt.Println(count)
    } 
}  
func comf(a int) int { 
    i := 10 
    top := a * a 
        for a / i > 0 { 
            i *= 10 
        }
    if a == top % i { 
        return 1 
    }
        return 0
}
~~~

#### 25. 自动售货系统

#### 26.记负均正

~~~go
package main 
import (
    "fmt"
)
func main(){
    var n int
    var num int
    for {
        _, err := fmt.Scan(&n)
        if err != nil{
            break
        }
        sum := 0.0
        count := 0
        count1 := 0
        for i := 0; i < n; i++{
            fmt.Scan(&num)
            if num > 0 {
                sum += float64(num)
                 count++ 
            } else if num < 0{
                count1++
            }
		}
            fmt.Printf("%d %.1f", count1, sum / float64(count))
            fmt.Println()
    }
}
~~~

#### 27.表示数字

~~~go
package main 
import (
    "fmt"
    "strings"
)
func main(){
  var inputStr string
    for{
        _, err := fmt.Scan(&inputStr)
        if err != nil{
            break
        }
  s := []byte(inputStr)
  var str string
  for i := 0; i < len(s); i++ {
    if s[i] >= '0' && s[i] <= '9' {           
       
        str =  str + "*" + string(s[i]) + "*"
    } else{
        str = str + string(s[i])
    }
}
b := strings.Split(str, "**")
var str2 string
for _, v := range b {
    str2 = str2 + v
}
fmt.Println(str2)
} 
}
~~~

#### 28.人民币转换

~~~go
package main 
import (

    "fmt"
    _"os"
    _"bufio"
    _"strings"
    "strconv"
    _"encoding/binary"
    _"sort"
    "regexp"
    "log"

)
func main(){

    var inputFlo float64
    fmt.Scanln(&inputFlo)
    
    str := "人民币" + ConvertNumToCny(inputFlo) 
    fmt.Println(str)

 
} 

func ConvertNumToCny(num float64) string {
    strnum := strconv.FormatFloat(num*100, 'f', 0, 64)
    sliceUnit := []string{"仟", "佰", "拾", "亿", "仟", "佰", "拾", "万", "仟", "佰", "拾", "元", "角", "分"}
    // log.Println(sliceUnit[:len(sliceUnit)-2])
    s := sliceUnit[len(sliceUnit)-len(strnum) : len(sliceUnit)]
    upperDigitUnit := map[string]string{"0": "零", "1": "壹", "2": "贰", "3": "叁", "4": "肆", "5": "伍", "6": "陆", "7": "柒", "8": "捌", "9": "玖"}
    str := ""
    for k, v := range strnum[:] {
        str = str + upperDigitUnit[string(v)] + s[k]
    }
    reg, err := regexp.Compile(`零角零分$`)
    str = reg.ReplaceAllString(str, "整")

    reg, err = regexp.Compile(`零角`)
    str = reg.ReplaceAllString(str, "零")

    reg, err = regexp.Compile(`零分$`)
    str = reg.ReplaceAllString(str, "整")

    reg, err = regexp.Compile(`零[仟佰拾]`)
    str = reg.ReplaceAllString(str, "零")

    reg, err = regexp.Compile(`零{2,}`)
    str = reg.ReplaceAllString(str, "零")

    reg, err = regexp.Compile(`零亿`)
    str = reg.ReplaceAllString(str, "亿")

    reg, err = regexp.Compile(`零万`)
    str = reg.ReplaceAllString(str, "万")

    reg, err = regexp.Compile(`零*元`)
    str = reg.ReplaceAllString(str, "元")

    reg, err = regexp.Compile(`亿零{0, 3}万`)
    str = reg.ReplaceAllString(str, "^元")

    reg, err = regexp.Compile(`零元`)
    str = reg.ReplaceAllString(str, "零")
    if err != nil {
        log.Fatal(err)
    }
    return str
}
~~~

#### 29.计票统计

~~~go
package main
import (
    "fmt"
)
func main() {
	var (
		n int 
		m int 
		str string
	)
	for {
		_, err := fmt.Scan(&n)
		if err != nil{
			break
		}
		s1 := make([]string, 0)
		s2 := make(map[string]int)
		
		for i := 0; i < n; i++{
			fmt.Scan(&str)
			s1 = append(s1, str)
			s2[str] = 0
		}
		inv := 0
		fmt.Scan(&m)
		for j := 0; j < m; j++{
			fmt.Scan(&str)

			if _, ok := s2[str]; ok {
				s2[str]++
			}else{
				inv++
			}
		}
		for _, v := range s1{
			fmt.Printf("%s : %d\n", v, s2[v])
		}
		fmt.Printf("Invalid : %d", inv)
        fmt.Println()
	}
}
~~~

#### 30.  

~~~go

~~~



#### 31. 在字符串中找出连续最长的数字串 

~~~go
package main
import (
	"fmt"
	"regexp"
	"strconv"
)
func main() {
    var inputStr string
    fmt.Scanln(&inputStr)
    pat := "[0-9]+"
    re, _ := regexp.Compile(pat)
    s := re.FindAllString(inputStr, -1)
    //fmt.Println(s)

    midNum := make([]int, len(s))
    for i :=0; i < len(s); i++{
        midNum[i] = commonF(s[i])
    }    
    maxVal := maxF(midNum)
    for i := 0; i < len(midNum); i++{
    
        if midNum[i] == maxVal {
            fmt.Println(s[i])
        }
    }
     fmt.Println(maxVal)
}
func maxF(a []int) int{

    maxValue := 0
    for i := 0; i < len(a); i++{
        if maxValue < a[i] {
            maxValue = a[i]
        }
    }
    return maxValue
}
func commonF(s string) int{
    i, _ := strconv.Atoi(s) 
    count := 1
        if i < 10 { 
            count = 1 
        }else{
            for{
                count++  
                i  = i / 10       
                if i < 10 {  
                    break
            }     
            }
        }    
    return count 
}
~~~

#### 32. 计算n x m的棋盘格子（n为横向的格子数，m为竖向的格子数）沿着各自边缘线从左上角走到右下角，总共有多少种走法 

~~~go
package main
import (
	"fmt"
)
func main() {
    var inputInt1 int
    var inputInt2 int
    for{
    _, err := fmt.Scan(&inputInt1)
    if err != nil{
        break
    }
    fmt.Scan(&inputInt2)
    fmt.Println(commonF(inputInt1, inputInt2))
    }
}
func commonF(a, b int) int{
    if a > 1 && b > 1{
        return commonF(a - 1, b) + commonF(a, b - 1)
    } else if (a >= 1 && b ==1) || (a == 1 && b >= 1){
        return a + b
    } else{
        return 0 
    }
}
~~~

#### 33.合法ip

~~~go
package main
import (
	"fmt"
	"regexp"
	_"strconv"
)
func main() {
    var inputStr string
    for{
        _, err := fmt.Scanln(&inputStr)
        if  err != nil{
            break
        }
    pat := "[0-9]+.[0-9]+.[0-9]+.[0-9]+"
    re, _ := regexp.Compile(pat)
    s := re.MatchString(inputStr)
    if s {
        fmt.Println("YES")
    }else{
        fmt.Println("NO")
    }
    }
}
~~~

#### 34.ASCII表

![](image\ASCII表.jpg)

#### 35.求最大连续bit数

~~~go
package main
import "fmt"
func main(){
    var n int
    for{
        _, err := fmt.Scan(&n)
        if err != nil{
            break
        }        
        fmt.Println(comf(n))
    }
}
func comf( a int) int {
    var t []int
    for a > 0 {
        tem := a % 2
        t = append(t, tem)
        a = a / 2
    }
	//fmt.Println(t)
	max := 0
	count := 0
	for i := 0; i < len(t); i++ {
		if t[i] == 1{
			count++
			if count > max {
				max = count
				
			}
		}else{
		count = 0
	}
	}
	return max
}
~~~

#### 37.获取字符串大写字母的个

~~~go
package main
import (
	"fmt"
)
func main() {
    for{
        var str string
        _,err:=fmt.Scan(&str)
        if err!=nil{
            return
        }
        b := []byte(str)
    count := 0
    for i := 0; i < len(b); i++{      
        if b[i] >= 'A' && b[i] <= 'Z'{
            count++
        }
    }
    fmt.Println(count)
    }
}
~~~

#### 38.二维数组

~~~go
package main
import (
	"fmt"
)
func main() {
   var (
       row int
       col int

       row1 int
       col1 int 

       row2 int
       col2 int 
    
       irow int
       icol int

       grow int
       gcol int

   )
   for{
        _, err := fmt.Scan(&row)

        if err != nil {
            break
        }
        
        fmt.Scan(&col)
        fmt.Scan(&row1)
        fmt.Scan(&col1)
        fmt.Scan(&row2)
        fmt.Scan(&col2)
        fmt.Scan(&irow)
        fmt.Scan(&icol)
        fmt.Scan(&grow)
        fmt.Scan(&gcol)

        res := make([]int, 5)

        if row <= 0 || col <= 0{
            res[0] = -1
        }
        if row1 < 0 || row1 >= row || col1 < 0 || col1 >= col || row2 < 0 || row2 >= row || col2 < 0 || col2 >= col{
            res[1] = -1
        }

        if irow < 0 || irow >= row{
            res[2] = -1
        }

        if icol < 0 || icol >= col {
            res[3] = -1
        }

        if grow < 0 || grow >= row || gcol < 0 || gcol >= col{
            res[4] = -1
        }

        for _, v := range res{
            fmt.Println(v)
        }
   }


}
~~~

#### 39.真分数分解为埃及分数

~~~go
package main
import (
	"fmt"
	_"regexp"
    "strconv"
    "strings"
)
func main() {

    for {

        var inputStr string
        _, err := fmt.Scan(&inputStr)
        if err != nil{
             break
        }
        var s []string
        s = strings.Split(inputStr, "/")

        num1, err := strconv.Atoi(s[0])
        if err != nil {
            //fmt.Println(err)
            return
        }
        num2, err1 := strconv.Atoi(s[1])
        if err1 != nil{
            //fmt.Println(err1)
            return
        }
        str := ""
        for{

            if num2 % (num1 - 1) == 0 {
                str = str + "1/" + strconv.Itoa(num2 / (num1 - 1)) + "+"
                num1 = 1
            }else{
                midNum := num2 /num1
                midNum2 := num2 - num1 * midNum
                str = str + "1/" + strconv.Itoa(midNum + 1) + "+"
                num1 = num1 - midNum2
                num2 = num2 * (midNum + 1)
                if num2 % num1 == 0{
                    num2 = num2 / num1
                    num1 = 1
                } 
            }
            if num1 == 1{
                break
            }
        }
        str = str + "1/" + strconv.Itoa(num2)
        fmt.Println(str)
    }
}
~~~

#### 40.字符串匹配

~~~go
package main

import(
    "fmt"
    "strings"
)
func main(){
    
    for{
    var strS, strL string
        
        
        _, err := fmt.Scan(&strS)
    if err != nil{
        //fmt.Println(err)
        return
    }
    fmt.Scan(&strL)
            var flag bool
        for _, v := range strS{
            if strings.IndexRune(strL, v) == -1{
                flag = true
                break
            }
        }
        
        fmt.Println(!flag)
    }
}
~~~

#### 41.数组排序

~~~go
package main
import (
	"fmt"
	_"regexp"
    _"strconv"
    _"strings"
    "sort"
)
func main() {
        for{
            var inputNum int
          _, err :=  fmt.Scan(&inputNum)
          if err !=nil {
              return
          }
            num1Slice := make([]int, 0)
        var num1 int
        for i := 0; i < inputNum; i++{
            fmt.Scan(&num1)
            num1Slice = append(num1Slice, num1)
        }
        var inputNum2 int
        _, err2 := fmt.Scan(&inputNum2)
        if err2 != nil{
            return
        }
        num2Slice := make([]int, 0)
        var num2 int
        for i := 0; i < inputNum2; i++{
            fmt.Scan(&num2)
            num2Slice = append(num2Slice, num2)
        }
        num3Slice := append(num1Slice, num2Slice...)               
        // fmt.Println(num3Slice)
        s2 := commonF(num3Slice)
        sort.Ints(s2)
        for _, v := range s2{
            fmt.Printf("%d", v)
            
        }
   fmt.Println()
        }
}
func commonF(s []int) []int{

    newS := make([]int, 0)
    for i := 0; i < len(s); i++{
        repeat := false
        for j := i + 1; j < len(s); j++{ 
            if s[i] == s[j]{ 
                repeat = true 
                break  
            } 
        }
        if !repeat {
            newS = append(newS, s[i])
        }
    }
    return newS
}
~~~

#### 43.尼科彻斯定理

~~~go
package main

import(
    "fmt"
    "strconv"
)
func main(){   
    for{
        var inputInt int
        _, err := fmt.Scan(&inputInt)
        if err != nil{
            return
        }        
        fmt.Println(comF(inputInt))
    }
}
func comF(a int) string{            
    b := make([]int, a)
    b[0] = a * a - a + 1
    str := strconv.Itoa(b[0])
    
    for i := 1; i < a; i++{
       b[i] = b[i - 1] + 2 
        str = str + "+" + strconv.Itoa(b[i])   
    }   
    return str   
}
~~~

#### 44.参数解析

~~~go
package main

import(
    "fmt"
	"strings"
	"bufio"
	"os"
)
func main(){
	reader := bufio.NewReader(os.Stdin)
    for {
		inputStr, err := reader.ReadString('\n')
        if err != nil {
            // fmt.Println("err: ", err)
            break
        }      
        s := strings.Fields(inputStr)
		fmt.Println(len(s))

		//fmt.Println(s)		
        for _, v := range s { 
            fmt.Println(v)
        } 
    }
}
~~~

#### 45. 计算日期到天数转换 

~~~go
package main

import(
    "fmt"
	_"strings"
	_"bufio"
    _"os"
    _"strconv"
)
func main(){
    
    m := [...]int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}


    var (
        year int
        mon int
        day int
    )
    for{
    _, err := fmt.Scan(&year)
    if err != nil{
        return
    }
    fmt.Scan(&mon)
    fmt.Scan(&day)
    
        if commonF(year){
            m[1] = 29
        }else{
            m[1] = 28
        }

        days := 0

        for i := 0; i < mon - 1; i++{
            day += m[i]
        }

        fmt.Println(days + day)
        //fmt.Println(all) 
}
}
func commonF(a int) bool {
    if (a % 4 == 0 && a % 100 != 0) || a % 400 == 0 {
        return true
    } else{
        return false
    } 

}
~~~

#### 46.买鸡问题

~~~go
package main

import(
    "fmt"
)
func main(){
  
    var m int
    for {
        _, err := fmt.Scan(&m)
        if err != nil{
            break
        }

        for x := 0; x <= 20; x++{
            y := (100 - 7 * x) / 4
            z := 75 + 3 * x /4
            if y > 0 && z > 0 && x + y + z == 100{
                fmt.Println(x, y, z)
            }
        }
    }
}
~~~

#### 47.字符串通配符

~~~go

~~~

#### 48.矩阵估值计算乘的次数

~~~go

~~~

#### 49.成绩排序

~~~go
package main

import(
    "fmt"
	_"strings"
	_"bufio"
    _"os"
    _"strconv"
    "sort"
)
type stu struct {
    name string
    sco int
}

func (s stu) String() string{
    return fmt.Sprintf("%s %d", s.name, s.sco)
}

type sortBySco []stu

func (s sortBySco) Swap(i, j int){
    s[i],s[j]=s[j],s[i]
}

func (s sortBySco) Len()int{
    return len(s)
}

func (s sortBySco) Less(i, j int) bool{
    return s[i].sco < s[j].sco
}
func main(){
    
    
    var n int
    var flag int
    
    for{
        
        _, err := fmt.Scan(&n)
        if err != nil{
            break
        }
        
        fmt.Scan(&flag)
        s := make(sortBySco, n)
        for i := 0; i < n; i++{
            fmt.Scan(&s[i].name, &s[i].sco)
        }
        
        
        if flag == 1 {
            sort.Stable(s)
            
            for k := range s{
                fmt.Printf("%s %d\n", s[k].name, s[k].sco)
            }
        }else if flag == 0 {
            sort.Stable(sort.Reverse(s))
              for k := range s{
                fmt.Printf("%s %d\n", s[k].name, s[k].sco)
            }
        }
    }

}
~~~



#### 51.配置文件恢复

#### 52.汽水瓶问题

~~~go
package main
import(
    "fmt"
    "io"
)
func main(){
    var n int
    for{
    _, err := fmt.Scan(&n)
    
    if err == io.EOF || n == 0{ 
        break 
    }
        count := 0 
        for n > 2 {
            count += n / 3
            n = n / 3 + n % 3
        }
        if n == 2 {
            count++
        }
        fmt.Println(count)
    }
}
~~~

#### 53.串的模式匹配

~~~go
package main
import(
    "fmt"
    "strings"
)
func main(){
    var str1 string
    var str2 string   
    for{
        _, err := fmt.Scan(&str1)
        if err != nil{
            break
        }
        fmt.Scan(&str2)
        
        if len(str2) < len(str1){
            str1, str2 = str2 , str1
        }	
	outer: for i := len(str1) ; i >= 0; i--{

		for j := 0; j < len(str1); j++{
			if j + i == len(str1) + 1{
				break
			}
			mid := str1[j:j+i]
			if strings.Contains(str2, mid){
				fmt.Println(mid)
				break outer
			}		
		}
	}
}
}
~~~

## LeetCode

#### 1.两个数之和

~~~go
//给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
func twoSum(nums []int, target int) []int {
    var a int
    var b int
    var n []int
    for i := 0; i < len(nums); i++{
        for j := 0; j < len(nums); j++{
            if i == j{
                continue
            } 
            
            if nums[i] + nums[j] == target{
                if i > j {
                   a = j
                   b = i
                  
                }else{
                    a = i
                    b = j
                }
            }
        }
    }
     n = append(n, a)
     n = append(n, b)
     return n
}
~~~

#### 2.整数反转

~~~go
func reverse(x int) int { 
    if x > 0 { 
    var a []int 
    for x > 0 {
        tmp := x % 10
        a = append(a, tmp)
        x = x / 10
        
    }
    //fmt.Println(a)
    mid := 0
    for i := 1; i < len(a) + 1; i++{
        mid = mid + a[len(a) - i] * exp(i)
    }
    return mid
}else{

    x = -x
    var a []int
    for x > 0 {
        tmp := x % 10
        a = append(a, tmp)
        x = x / 10
        
    }
    //fmt.Println(a)
    mid := 0
    for i := 1; i < len(a) + 1; i++{
        mid = mid + a[len(a) - i] * exp(i)
    }
    return -mid
}

}

func exp(a int) int{

    b := 1
    for i := 0; i < a - 1; i++{
        b = b * 10
    }
    return b
}
~~~

#### 3.回文数

~~~go
func isPalindrome(x int) bool {
    if x < 0 {
         return false
    }
    str := strconv.Itoa(x)
    j := len(str) - 1
    for i := 0; i < len(str)/2; i++{
        if str[i] != str[j]{
            return false
        }
        j--
    }
    return true
}
~~~

#### 4.罗马数字转int

~~~go
func romanToInt(s string) int{
    res := 0
    for s != ""{
    if mid1 := strings.Index(s, "CD"); mid1 != -1{
        res += 400
        s = strings.Replace(s, "CD", "", 1)
    }

    if mid2 := strings.Index(s, "CM"); mid2 != -1{
        res += 900
        s = strings.Replace(s, "CM", "", 1)
    }

    if mid3 := strings.Index(s, "XL"); mid3 != -1{
        res += 40
        s = strings.Replace(s, "XL", "", 1)
    }

    if mid4 := strings.Index(s, "XC"); mid4 != -1{
        res += 90
        s = strings.Replace(s, "XC", "", 1)
    }

    if mid5 := strings.Index(s, "IV"); mid5 != -1{
        res += 4
        s = strings.Replace(s, "IV", "", 1)
    }

    if mid6 := strings.Index(s, "IX"); mid6 != -1{
        res += 9
        s = strings.Replace(s, "IX", "", 1)
    }

    for _, v := range s {
        if string(v) == "I"{
            res += 1
            s= strings.Replace(s, "I", "", 1)
        }

        if string(v) == "V"{
            res += 5
            s= strings.Replace(s, "V", "", 1)
        }

        if string(v) == "X"{
            res += 10
            s= strings.Replace(s, "X", "", 1)
        }

        if string(v) == "L"{
            res += 50
            s= strings.Replace(s, "L", "", 1)
        }

        if string(v) == "C"{
            res += 100
            s= strings.Replace(s, "C", "", 1)
        }

        if string(v) == "D"{
            res += 500
            s= strings.Replace(s, "D", "", 1)
        }

        if string(v) == "M"{
            res += 1000
            s= strings.Replace(s, "M", "", 1)
        }
    }
    }
    return res
}
~~~

#### 5.最长公共前缀

~~~go
func longestCommonPrefix(strs []string) string {
    
    if len(strs) == 0{
        return ""
    }
    str := strs[0]
    for i := 1; i < len(strs); i++{
        if strs[i] < str{
            str = strs[i]
        }
    }
    var a []string
    
    outer: for i := 1; i <= len(str); i++{
        
        for j := 0; j < len(strs); j++{
            if strs[0][i - 1:i] != strs[j][i - 1:i]{
                break outer
            }
            
        }
        a = append(a, strs[0][i - 1:i])
    }
    str1 := ""
    for _, v := range a {
        str1 = str1 + v
    }
    return str1   
}
~~~

#### 6.有效的括号

~~~go
func isValid(s string) bool {  
    flag := false
    if len(s) == 0 {
         return true
    }
    m := map[byte]byte{'(':')','{':'}','[':']'}  
    sli := make([]byte, 0) 
    if len(s) % 2 == 1{ 
        return false 
    }
    for i, b := range s { 
        
        if i == 0 && (s[i] == ')' || s[i] == ']' || s[i] == '}'){  
            return false
        }

        if b == '(' || b == '[' || b == '{'{
            sli = append(sli, byte(b)) 
        }else if b ==')' || b == ']' || b == '}'{ 
            left := sli[len(sli) - 1] 
            sli = sli[:len(sli) - 1] 
            if m[left] == byte(b){ 
                flag = true 
            }else{ 
                return false 
            }
        }        
        if i == len(s)-1 && len(sli) != 0 {  
			flag = false 
		} 
    }
    return flag
}

//方法二
func test(s string) bool {

	m := make(map[string]string, 3)
	m["]"] = "["
	m[")"] = "("
	m["}"] = "{"
	var stack []string
	if len(s) == 0 {
		return true
	}
	for i := 0; i < len(s); i++ {
		if len(stack) == 0 {
			stack = append(stack, string(s[i]))
		} else {
			if stack[len(stack)-1] == m[string(s[i])] {
				stack = stack[:len(stack)-1]
			} else {
				stack = append(stack, string(s[i]))
			}
		}

	}
	if len(stack) == 0 {
		return true
	}
	return false
}

~~~

#### 7.合并两个有序链表

~~~go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
         return l2
    }
    if l2 == nil {
        return l1  
    }
    var res *ListNode
    if l1.Val >= l2.Val{  
        res = l2
        res.Next =  mergeTwoLists(l1, l2.Next)
    }else{
        res = l1
        res.Next = mergeTwoLists(l1.Next, l2)
    }
    return res
}
//方法二
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
        var  data []int
        if l1 == nil{
            return l2
        }
        if l2 == nil{
            return l1
        }
for l1 != nil {
           data = append(data, l1.Val)
           l1 = l1.Next      
    }       
for l2 != nil{
           data = append(data, l2.Val) 
           l2 = l2.Next    
    }    
    sort.Ints(data)
    l3 := &ListNode{data[0], nil}
    l4 := l3
    for i := 1; i < len(data); i++{
        l4.Next = &ListNode{data[i], nil}
        l4 = l4.Next
    return l3
}
~~~

#### 8.删除切片中的重复项

~~~go
func removeDuplicates(nums []int) int {
 
    k := 0
   
    for i := 0; i < len(nums); i++{
        if nums[i] != nums[k]{
            k++
            nums[k] = nums[i]
        }
    }
    return k + 1 
}
~~~

#### 9.移除元素

~~~go
func removeElement(nums []int, val int) int {   
    index := 0
    for ; index < len(nums);{
        if nums[index] == val{
        nums = append(nums[:index],nums[index+1:]...)
        continue
        }
        index++
    }
    return len(nums)
}
~~~

#### 10.实现strStr()

~~~go
func strStr(haystack string, needle string) int {
    return strings.Index(haystack, needle)
}
~~~

#### 11.搜索插入位置

~~~go
func searchInsert(nums []int, target int) int {
    index := 0
    for  i := 0; i < len(nums); i++{
        if nums[i] >= target{
            index = i
            break
    
        }else if nums[i] < target && i == len(nums) - 1{
            index = i + 1
            break
        }
    }
    return index
}
~~~

#### 11.最大子序和

~~~go
func maxSubArray(nums []int) int {
    
    if len(nums) == 0{
         return 0
    }
    if len(nums) == 1{
         return nums[0]
    }
    max := -2147483648
    for i := 0; i < len(nums); i++{
        temp := 0
        max2 := -2147483648
        for j := i; j < len(nums); j++{
            temp += nums[j]
            if max2 < temp {
                    max2 = temp
            }
        }
        if max2 > max {
            max = max2
        }
    }
    return max
}
~~~

#### 12.最后一个单词长度

~~~go
func lengthOfLastWord(s string) int {
   str :=  strings.Fields(s)
   if len(str) == 0 {
        return 0
   }
    return len(str[len(str)-1])
}
~~~

#### 13.加一

~~~go
func plusOne(digits []int) []int {
    digits[len(digits) - 1] += 1

    for i := len(digits) - 1; i >=0; i--{
        if i != 0 && digits[i] > 9 {
            digits[i] = 0
            digits[i - 1] += 1 
        }else if i == 0 && digits[i] > 9{
            digits[i] = 0
            digits = append([]int{1}, digits...)
        }
    }
    return digits
}
~~~

#### 14.求平方

~~~go
//first method
func mySqrt(x int) int {
    b := float64(x)
    c := math.Sqrt(b)
    return int(c)
}

//newton method

~~~

- 牛顿迭代法求方根的迭代公式：X~n+1~ = X~n~ - f(X~n~)/f`(X~n~)

####15.跳楼梯（斐波那契）

~~~go
func climbStairs(n int) int {
    a := []int{1, 2, 3}
    if n < 3 {
        return a[n - 1]
    }
    for i := 3; i < n; i++{
        a = append(a, a[i-1] + a[i-2])
    }
    return a[len(a) - 1]
}
//第二种 性能差
func climbStairs(n int) int {   
    if n ==1 || n == 2{
        return n
    }else {
        return climbStairs(n-1) + climbStairs(n-2)
    }
~~~

#### 16.去除链表中的重复元素

~~~go
//第一种 比较笨
func deleteDuplicates(head *ListNode) *ListNode {
    var mid []int
    if head == nil {
        return nil
    }
    mid = append(mid, head.Val)
    for head.Next != nil{
        head = head.Next
        mid = append(mid, head.Val)
        
    }
    
    b := remove(mid)
    l1 := &ListNode{b[0], nil}

    l2 := l1 
    for i := 1; i < len(b); i++{
        l2.Next = &ListNode{b[i], nil}
        l2 = l2.Next
    }
    return l1
}
func remove(a []int) []int{
    var b []int
    for i := 0; i < len(a); i++{
        repeat := false
       for j := i + 1; j < len(a); j++{
           if a[i] == a[j]{
               repeat = true
               break
           }
       }
       if !repeat {
           b = append(b, a[i])
       }
    }
    return b
}
//第二种 快捷
func deleteDuplicates(head *ListNode) *ListNode {
    if head == nil{
         return nil
    }
    head1 := head
    for head1.Next != nil{
    if head1.Val == head1.Next.Val{
        head1.Next = head1.Next.Next
    }else{
        head1 = head1.Next
    }
    }
    return head
}
~~~

#### 17.合并两个有序数组

~~~go
func merge(nums1 []int, m int, nums2 []int, n int)  {
    for i := 0; i < n; i++{
        nums1[m] = nums2[i]
        m++
    }
    sort.Ints(nums1)
}
~~~

#### 18.相同的树

~~~go
func isSameTree(p *TreeNode, q *TreeNode) bool {
    if p == nil && q == nil{
        return true
    }
    if p == nil || q == nil{
        return false
    }
    if q.Val != p.Val{
        return false
    }
    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)
}
~~~

#### 19.对称二叉树

~~~go
func isSymmetric(root *TreeNode) bool {
    	if root == nil{
		return true
	} else {
		return same(root.Right, root.Left)
	}
}
func same(l *TreeNode, r *TreeNode) bool{
    if l == nil && r == nil {
        return true
    } 
    if l == nil || r == nil{ 
        return false
    }
    if l.Val == r.Val{
        return same(l.Right, r.Left) && same(l.Left, r.Right) 
    }else{
        return false
    }
}
~~~

#### 20. 二叉树最大深度

~~~go
func maxDepth(root *TreeNode) int {  
    if root == nil {    
         return 0    
    }  
    i := 0    
    j := 0    
    i = maxDepth(root.Left) + 1   
    j = maxDepth(root.Right) + 1   
    if j > i {  
         i, j = j, i 
    }
    return i  
}  
~~~

#### 21.将有序数组转换为二叉搜索树

~~~go
func sortedArrayToBST(nums []int) *TreeNode {
    if len(nums) == 0{
         return nil 
    }
    return buildtree(nums, 0, len(nums) - 1) 
}
func buildtree(n []int, i,j int) *TreeNode{
    if i > j {
        return nil
    }
    mid := (i + j) / 2
    n1 := &TreeNode{n[mid], nil, nil}
    n1.Left = buildtree(n, i, mid - 1)
    n1.Right = buildtree(n, mid + 1, j)
    return n1
}
~~~

#### 22.判断平衡二叉树

~~~go
func isBalanced(root *TreeNode) bool {
    if root == nil {
        return true
    }
    i := compare(root.Left)
    j := compare(root.Right)
    
    if math.Abs(float64(j - i)) > 1{
        return false
    }
    if isBalanced(root.Left) == false {
        return false
    }
    if isBalanced(root.Right) == false {
        return false
    }
    return true
}
func compare(root *TreeNode) int{
        if root == nil{
        return 0
    }
    i := 0
    j := 0
    i = compare(root.Left) + 1
    j = compare(root.Right) + 1
        if j > i {  
         i, j = j, i 
    }
    return i
}
~~~

#### 23.最小深度

~~~go
func minDepth(root *TreeNode) int {
   if root == nil {
         return 0
    }   
    i := minDepth(root.Left) + 1
    j := minDepth(root.Right) + 1
	//左子树为0 返回右子树深度+1 右子树为0 返回左子树深度+1
    if i == 1 ||  j == 1{
        return i + j - 1
    }
    if i > j {
        i, j = j, i
    }
    return i
}
~~~

#### 24.路径总和

~~~go
func hasPathSum(root *TreeNode, sum int) bool {
    if root == nil {
         return false
    }
    if root.Left == nil && root.Right == nil {
        return sum - root.Val == 0
    }
    return hasPathSum(root.Left, sum - root.Val) || hasPathSum(root.Right, sum - root.Val)
}
~~~

#### 25.杨辉三角2

~~~go
func getRow(rowIndex int) []int {
    var a [][]int
    a = append(a, []int{1})
        if rowIndex == 0{
         return a[0]
    }
    for i := 1; i <= rowIndex+1; i++{
        temp := make([]int, 0)
        temp = append(temp, 1)
        for j := 1; j < i - 1; j++{
            temp = append(temp, a[i-1][j-1] + a[i-1][j])
        }
        temp = append(temp, 1)
        a = append(a, temp)
    }
    return a[rowIndex+1]
}
~~~

#### 26.卖股票最佳时机

~~~go
func maxProfit(prices []int) int {
    max := -100000
    for i := 0; i < len(prices); i++{
        mid := -10000
        for j := i + 1; j < len(prices); j++{
            temp := prices[j] - prices[i]
            if mid  < temp {
                mid = temp
            }
        }
        if max < mid {
            max = mid
        }
    }
    if max < 0 {
        return 0
    }
    return max 
}
~~~

#### 27.买卖股票最佳时机2

~~~go
func maxProfit(prices []int) int {
    res := 0
    for i := 0; i < len(prices) - 1; i++{
        if prices[i + 1] > prices[i] {
            res += prices[i + 1] - prices[i]
        }   
    }
    return res
}
~~~

#### 28.判断一个字符串是不是回文串

~~~go
func isPalindrome(s string) bool {
    if s == ""{
        return true
    }
    s = strings.ToLower(s)
    var str []string   
    for _, v := range s {
        if (v >= 'a' && v <= 'z') || (v >= '0' && v <= '9') {
            str = append(str, string(v))
        }
    }
    for i := 0; i < len(str)/2; i++{
        if str[i] != str[len(str) - i - 1]{
            return false
        }
    }
    return true
}
~~~

#### 29.只出现一次的数字

~~~go
func singleNumber(nums []int) int {
    index := 0
    for _, v := range nums{
        index ^= v
    }
    return index
}
~~~

#### 30.最小栈

~~~go
type MinStack struct {
    elems []int
    min []int
}
/** initialize your data structure here. */
func Constructor() MinStack {
    return MinStack{make([]int, 0), make([]int, 0)}

}
func (this *MinStack) Push(x int)  {
    this.elems = append(this.elems, x)

    if len(this.min) == 0 || this.GetMin() >= x{
        this.min = append(this.min, x)
    }
}
func (this *MinStack) Pop()  {
    elem := this.Top()

    this.elems = this.elems[:len(this.elems)-1]
 
	if elem <= this.GetMin() {
		this.min = this.min[:len(this.min)-1]
	}
}
func (this *MinStack) Top() int {
    	if len(this.elems) == 0 {
		panic("empty stack")
	}
 
	elem := this.elems[len(this.elems)-1]
	return elem
}
func (this *MinStack) GetMin() int {
    	if len(this.min) == 0 {
		panic("empty stack")
	}
	elem := this.min[len(this.min)-1]
	return elem
}
~~~

#### 31.相交链表

~~~go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    a, b := headA, headB
    for a != b{
        if a == nil{
            a = headB
        }else{
            a = a.Next
        }
        if b == nil{
            b =headA
        }else{
            b = b.Next
        }
    }
    return a
}
~~~

#### 32.两数之和2

~~~go
func twoSum(numbers []int, target int) []int { 
    var a []int
    outer:for i := 0; i < len(numbers) - 1; i++{
            for j := i + 1; j < len(numbers); j++{
                if numbers[i] + numbers[j] == target{
                    a = append(a, i+1)
                    a = append(a, j+1)
                    break outer
                }
            }
    }
    return a 
}
//方法二
//一个双向同时遍历的方法
    for i,j := 0, 10; i < j;{
        j--
        i++
        fmt.Print(" i = ", i)
        fmt.Println()
        fmt.Print(" j = ", j)
    }
//好一点方法
func twoSum(numbers []int, target int) []int {
	for i, j := 0, len(numbers)-1; i < j; {
		if numbers[i]+numbers[j] > target {
			j--
		} else if numbers[i]+numbers[j] < target {
			i++
		} else {
			return []int{i+1, j+1}
		}
	}
	return []int{}
}
~~~

#### 33. Excel表列名称

~~~go

~~~

#### 34.多数元素

~~~go
func majorityElement(nums []int) int {
    if len(nums) == 1{
        return nums[0]
    }
    flag := len(nums)/2 + 1
    res := -1
   outer: for i := 0; i <len(nums); i++{
        count := 1
        for j := i + 1; j < len(nums); j++{
            if nums[i] == nums[j]{
                count++
            }
            if flag <= count {
             res = nums[i]   
             break outer
            } 
        }
    }
    return res
}

//2
func majorityElement(nums []int) int {
    sort.Ints(nums)
    return nums[len(nums)/2]
}

//3
func majorityElement(nums []int) int {
    max := nums[0]
    maxMap := map[int]int{max: 0}
    for i:=0; i<len(nums); i++ {
        maxMap[nums[i]]++
        if maxMap[nums[i]] > maxMap[max] {
            max = nums[i]
        }
    }
    return max
}
~~~

#### 35.阶乘后的零

~~~go
func trailingZeroes(n int) int {  
    res := 0
    for n >= 5{
        res += n / 5
        n = n / 5
    }
    return res
}
~~~

#### 36.旋转数组

~~~go
func rotate(nums []int, k int)  {  
     if len(nums) < k {
         k = k % len(nums)
     }
     a := len(nums)
     mid1 := nums[a - k:]
     mid2 := nums[:a-k]
     mid1 = append(mid1, mid2...) 
     nums = append(nums[:0], mid1...)  
}
~~~

#### 37.颠倒二进制位

~~~go
func reverseBits(num uint32) uint32 {
	str := strconv.FormatUint(uint64(num), 2)
	//fmt.Println(str)
	rev := ""
	for i := len(str); i > 0; i-- {
		rev = rev + str[i-1:i]
	}
	if len(rev) < 32 {
		rev = rev + strings.Repeat("0", 32-len(rev))
	}
	//fmt.Println(rev)
	res, _ := strconv.ParseUint(rev, 2, 64)
	return uint32(res)
}

//由于Go对类型的操作十分严谨，uint32必须和同类型的内置uint32类型进行操作。所以count不能简单地声明为int或者其他整型, 因此当count为0的时候需要多插入一个if statement去结束for循环，不然会引起死循环

//位运算 重点要看的

func reverseBits(num uint32) uint32 {
    bits, count := uint32(0), uint32(31)
    
    for count >= 0 {
        bits |= (num & 1) << count
        num >>= 1
        if (count == 0) {
            return bits
        }
        count--
    }
    return bits
}
~~~

#### 38.有效的电话号码

~~~shell
egrep '^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$' file.txt
~~~

#### 39.打家劫舍

~~~go
//没学会 重点要看
func rob(nums []int) int {
	prevMax, curMax := 0, 0
	for _, v := range nums {
		temp := curMax
		if prevMax+v > curMax {
			curMax = prevMax + v
		}
		prevMax = temp
	}
	return curMax
}
~~~

#### 40.快乐数

~~~go
func isHappy(n int) bool {
    //判断一个数是否出现过的方法 
    //创建一个map[int]bool
    //赋值 m[i] = true
    //if _, ok := i; ok {return false} 
    //m[i] = true
	m := make(map[int]bool)
	sum := nex(n)
	m[sum] = true
	for {
		if sum == 1 {
			return true
		}
		sum = nex(sum)
		if _, ok := m[sum]; ok {
			return false
		}
		m[sum] = true
	}

}
func nex(n int) int {
	sum := 0
	s := 0
	for n != 0 {
		s = n % 10
		sum += s * s
		n /= 10
	}
	return sum
}
~~~

#### 41.移除链表元素

~~~go
func removeElements(head *ListNode, val int) *ListNode { 
    if head == nil {
        return nil
    }
    mid := &ListNode{}
    mid.Next = head
    tem := mid
    for tem.Next != nil{
        if tem.Next.Val == val {
             tem.Next = tem.Next.Next
        }else{
        tem = tem.Next 
        }
    }
    return mid.Next
}
~~~

#### 42.找出小于n的所有质数

~~~go
func countPrimes(n int) int {   
    m := make(map[int]bool, n)
    count := 0
    for i := 2; i < n; i++{
        if m[i] {
            continue
        }
        for j := i + i; j < n; j = j + i{
            m[j] = true
        }
        count++
    }
    return count
}
~~~

#### 43.同构字符串

~~~go
func isIsomorphic(s string, t string) bool {
	if s == "" && t == "" {
		return true
	}
	if len(s) != len(t) {
		return false
	}
	s1 := []byte(s)
	t1 := []byte(t)

	for i := 0; i < len(s1); i++ {
		if bytes.IndexByte(s1, s1[i]) != bytes.IndexByte(t1, t1[i]) {
			return false
			break
		}
	}
	return true
}
~~~

#### 44.反转链表

~~~go
func reverseList(head *ListNode) *ListNode { // 迭代方法，原地反转链表
	var pre *ListNode = nil
	var cur *ListNode = head
	var temp *ListNode
	for cur != nil {
		temp = cur.Next
		cur.Next = pre
		pre = cur
		cur = temp
	}
	return pre
}
~~~

#### 45.存在重复元素

~~~go
func containsDuplicate(nums []int) bool {
	m := make(map[int]bool, len(nums))
	for i := 0; i < len(nums); i++ {
		if _, ok := m[nums[i]]; ok {
			return true
		}
		m[nums[i]] = true
    }
    return false 
}
~~~

#### 46.存在重复元素2

~~~go
func containsNearbyDuplicate(nums []int, k int) bool {
    m := make(map[int]int, len(nums))
    for i := 0; i < len(nums); i++{
        if _, ok := m[nums[i]]; ok && m[nums[i]] >= i{
            return true
        }
        m[nums[i]] = i + k
    }
     return false
}
~~~

#### 47.用队列实现栈

~~~go
type MyStack struct {
    data []int
}
/** Initialize your data structure here. */
func Constructor() MyStack {
    return MyStack{}    
}
/** Push element x onto stack. */
func (this *MyStack) Push(x int)  {
    this.data = append(this.data, x)
}
/** Removes the element on top of the stack and returns that element. */
func (this *MyStack) Pop() int {
        top := this.data[len(this.data) - 1]
        this.data = this.data[:len(this.data)-1]
        return top
}
/** Get the top element. */
func (this *MyStack) Top() int {
    return this.data[len(this.data) - 1]
}
/** Returns whether the stack is empty. */
func (this *MyStack) Empty() bool {
    if len(this.data) == 0{
        return true
    }
    return false
}
~~~

#### 48.反正二叉树

~~~go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
         return nil
    }
    invertTree(root.Left)
    invertTree(root.Right)
    root.Left, root.Right = root.Right, root.Left
    return root
}
~~~

#### 49.2的幂

~~~go
func isPowerOfTwo(n int) bool {
    if n == 1 || n == 2{
		return true
	}
	var flag bool
	temp := 0
	for i := 1; ; i++ {
		temp = 2 << i
		if n < temp {
			flag = false
			break
		}
		if temp == n {
			flag = true
			break
		}
	}
	return flag
}
~~~

## 数据结构

#### 堆栈 队列

- 堆（heap） 也被称为优先队列 队列允许的操作是**先进先出**（FIFO） 队尾插入元素 队头取出元素 而堆也一样 在堆底插入元素 在堆顶取出元素 
- 栈（stack）又名堆栈 是一个**先进后出**的数据结构 他一种运算受限的线性表 其限制是仅允许在表的一端进行插入和删除运算 这一端被称为栈顶 把另一端成为栈底 插入元素被称为进栈 入栈 压栈 删除元素被称为出栈 退栈
- 队列 是一种特殊的线性表 特殊之处是只允许在表的前端进行删除操作 而在表的后端进行插入操作 **先进先出**（FIFO）(和堆差不多)

### 运维

1. 三次握手

   ​	客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认。第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

   ​	客户端与服务器开始传送数据简版：首先A向B发SYN（同步请求），然后B回复SYN+ACK（同步请求应答），最后A回复ACK确认，这样TCP的一次连接（三次握手）的过程就建立了。

2. 四次挥手

   ​	这是因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。

   但是关闭连接时，当Client端发送FIN报文仅仅表示它不再发送数据但是还能接收数据，Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手

   ![](image\interview\sevenceng.png)	![](E:image\interview\thirdhandshake.png)

   3. shell 面试题 https://www.jb51.net/article/135168.htm

   4.  top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况 

   5. haproxy nginx lvs 对比

   6. docker容器时间跟本地时间不一致怎样解决  共享本地的/etc/localtime到容器

   7. 编写个shell 脚本将/boot/grub/目录下大于100K 的文件转移到/opt 目录下   find /boot/grub -size +100k -type f -exec mv {} /opt \
   
      ~~~shell
      #/bin/bash
      cd /boot/grub
      for file in `ls /boot/grub`;do
      if [ -f $file ];then
       if [ `ls -l $file | awk '{print $5}'` -gt 102400 ];then
       mv $file /opt
       fi
      fi
   done
      ~~~

   8. 查看某进程所打开的所有文件  lsof -p pid
   
   9. 明天继续看 https://blog.csdn.net/yuanfangpoet/article/details/96774478

### 面试知识点

####设计模式

1. 观察者模式
2. 工厂模式
3. 命令链模式
4. 单例模式
5. 策略模式
6. 建筑者模式：https://www.jianshu.com/p/e2a2fe3555b9

####~~~mysql优化和高可用~~

1. ~~服务器性能剖析~~
2. ~~mysql查询~~
3. ~~mysql分库分表~~
4. ~~mysql索引优化~~
5. ~~主从复制以及读写分离~~
6. ~~数据库中间件mycat~~

####~~微服务~~

1. ~~服务注册发现~~
2. ~~API网关~~
3. ~~配置中心~~
4. ~~事件调度（kafka)~~
5. ~~服务跟踪（starter-sleuth）~~
6. ~~服务熔断（Hystrix）~~

####~~分布式存储redis~~

1. ~~缓存雪崩~~
2. ~~缓存穿透~~
3. ~~缓存预热~~
4. ~~缓存更新~~
5. ~~缓存降级~~

####网络编程

1. 网络七层架构
2. TCP/IP
3. TCP三次握手 四次挥手
4. HTTP原理

- ES

## 6.经典面试题

### 1.回溯算法

#### 1.[46. 全排列](https://leetcode-cn.com/problems/permutations/)

全排列回溯法两种写法

~~~go
//函数变量
func permute(nums []int) [][]int {
    res := make([][]int, 0)
    

    var dfs func(nums []int, b []int)

    dfs = func(nums, b []int) {
        if len(nums) == len(b) {
            x := make([]int, len(b))
            copy(x, b)
            res = append(res, x)
            return
        }
        for i := 0; i < len(nums); i++ {
            if contain(b, nums[i]){
                continue
            }
            b = append(b, nums[i])
            dfs(nums, b)
            b = b[:len(b)-1]
        }
    }
    c := make([]int, 0)
    dfs(nums, c)
    return res
    
}

func contain(a []int, b int) bool {
    for i := 0; i < len(a); i++ {
        if a[i] == b {
            return true

        }
    }

    return false
}
~~~

~~~go
//递归函数
func permute(nums []int) [][]int {
    res = [][]int{}
    var m []int
    backTrace(nums, m)
    return res
}

var res [][]int
func backTrace(nums []int, m []int) {
    if len(m) == len(nums) {
        x := make([]int, len(nums))
        copy(x, m)
        res = append(res, x)
        return 
    }
    
    for i := 0; i < len(nums); i++ {
        if contain(m, nums[i]) {
            continue
        }
        m = append(m, nums[i])
        backTrace(nums, m)
        m = m[:len(m)-1]
    }
}

func contain(s []int, a int) bool {
    for i := 0; i < len(s); i++ {
        if s[i] == a {
            return true
        }
    }
    return false
}


~~~

~~~go
//交换
func permute(nums []int) [][]int {
    res = [][]int{}
    backTrace(nums, 0)
    return res 
}

var res [][]int
func backTrace(nums []int, index int) {

    if len(nums) == index {
        temp := []int{}
        for i := 0; i<len(nums); i++ {
            temp = append(temp, nums[i])
        }
        res = append(res, temp)
        return
    }

    for i := index; i < len(nums); i++ {
        nums[i], nums[index] = nums[index], nums[i]
        backTrace(nums, index+1)
        nums[i], nums[index] = nums[index], nums[i]
    }
}
~~~

- #### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

 给定一个可包含重复数字的序列，返回所有不重复的全排列 

```
输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

~~~go
func permuteUnique(nums []int) [][]int {
    res = [][]int{}

    backTrace(nums, 0)
    return res
}

var res [][]int 

func backTrace(nums []int, index int){

    if len(nums) == index {
        x := make([]int, len(nums))
        copy(x, nums)
        res = append(res, x)
    }
    m := map[int]int{}
    for i := index; i < len(nums); i++ {
        _, ok := m[nums[i]]
        if ok {
            continue
        }

        nums[i], nums[index] = nums[index], nums[i]
        backTrace(nums, index+1)
        nums[i], nums[index] = nums[index], nums[i]
        m[nums[i]] = 1
    }
}
~~~

####2.[51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

~~~go
//代码
func solveNQueens(n int) [][]string {
    result = [][]string{}
    queens := make([]int, n)
    for i := 0; i < n; i++ {
        queens[i] = -1
    }
    col := map[int]bool{}
    diag2 := map[int]bool{}
    diag1 := map[int]bool{}
    backTrace(0, n, queens, col, diag1, diag2)
    return result
}

var result [][]string
func backTrace(row, n int, queens []int, col, diag1, diag2 map[int]bool) {


    if row == n {
        mid := generate(queens)
        result = append(result, mid)
    }

    for i := 0; i < n; i++ {
        if col[i] {
            continue
        }

        if diag1[row-i] {
            continue
        }

        if diag2[row+i] {
            continue
        }

        col[i] = true
        diag1[row-i] = true
        diag2[row+i] = true

        queens[row] = i 
        backTrace(row+1, n, queens, col, diag1, diag2)
        queens[row] = -1
        col[i] = false
        diag1[row-i] = false
        diag2[row+i] = false
    }
}

func generate(queens []int) []string{
    res := []string{}
    
    for i := 0; i < len(queens); i++ {
        s := make([]byte, len(queens))
        for j := 0; j < len(queens); j++ {
            s[j] = '.'
        }
        s[queens[i]] = 'Q'
        res = append(res, string(s))
    }
    return res
}
~~~



####3.[22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

~~~go
//回溯法
func generateParenthesis(n int) []string {

    s := ""
    left := n
    right := n

    res := &[]string{}

    backTrace(left, right, s, res)
    return *res

}


func backTrace(left, right int, s string, res *[]string) {
    if left < 0 {
        return 
    }
    if right < 0 {
        return
    }

    if right < left {
        return
    }
    if right == 0 && right == 0 {
        *res = append(*res, s)
        return
    }

    s += "("
    backTrace(left-1, right, s, res)
    s = s[:len(s)-1]

    s += ")"
    backTrace(left, right-1, s, res)
    s = s[:len(s)-1]
}
~~~

#### 4.[17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母

~~~go
func letterCombinations(digits string) []string {
    if len(digits) == 0 {
        return []string{}
    }
    res = []string{}
    backTrace(digits, "", 0)
    return res
}

var m map[string]string = map[string]string{
    "2": "abc",
    "3": "def",
    "4": "ghi",
    "5": "jkl",
    "6": "mno",
    "7": "pqrs",
    "8": "tuv",
    "9": "wxyz",
}

var res []string

func backTrace(digits string, path string, index int) {

    if len(digits) == len(path) {
        res = append(res, path)
        return
    }

    mid := m[string(digits[index])]
    for i := 0; i < len(mid); i++ {
        path += string(mid[i])
        backTrace(digits, path, index+1)
        path = path[:len(path)-1]
    }
}
~~~



### 2.动态规划

#### 1.[ 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

#### 2.[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

~~~c++
func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    for i := 1; i < len(nums); i++ {
        dp[i] = max(dp[i-1]+nums[i], nums[i]) 
    }
    res := -1 << 31
    for i := 0; i < len(nums); i++ {
        if dp[i] > res {
            res = dp[i]
        }
    }
    return res
}
func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
~~~

- 1，2题的解法类似，通过dp[i]表示在num[i]处的最大值，所以最后的结果应该是dp数组中的最大值，而不是dp[len(num)]

![](E:\devopsdocs\image\alg\dp1.png)

#### 3.[买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

#### 4.[买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

#### 5.[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

#### 6.[188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

#### 7.[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

#### 8.[714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

- 股票问题一共有6个题，可以参考[labuladong的翻译文章](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484508&idx=1&sn=42cae6e7c5ccab1f156a83ea65b00b78&chksm=9bd7fa54aca07342d12ae149dac3dfa76dc42bcdd55df2c71e78f92dedbbcbdb36dec56ac13b&scene=21#wechat_redirect)，套用模板

![](image\alg\dpstock.png)

#### 9.[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

#### 10.[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

- 这两个动态规划问题的思路是一样的， 解决两个字符串的动态规划问题，一般都是用两个指针i， j分别指向两个字符串的最后， 然后一步步往前走，缩小问题的规模，主要使用的方法是 dp table

![](image\alg\dptable.png)

参考[labuladong的文章](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=3&sn=aa642cbf670feee73e20428775dff0b5&chksm=9bd7fb33aca0722568ab71ead8d23e3a9422515800f0587ff7c6ef93ad45b91b9e9920d8728e&scene=178#rd)可以得到状态转移方程

![](image\alg\dptable2.png)[416. 分

####11.[416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)(0-1背包)

#### 12.[494. 目标和](https://leetcode-cn.com/problems/target-sum/)（0-1背包（背满））

#### 13.[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)（完全背包）

#### 13-2.[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)（完全背包）

#### 13-3.[面试题 08.11. 硬币](https://leetcode-cn.com/problems/coin-lcci/)（完全背包）

####14.[392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

~~~go
//判断子序列和最长公共子序的做法一样 都是求在最后一个dp值 通用模板
func isSubsequence(s string, t string) bool {
    if len(s) == 0 && len(t) == 0 {
        return true
    }
    dp := make([][]int, len(s)+1)
    for i := 0; i <= len(s); i++ {
        dp[i] = make([]int, len(t)+1)
    }
    for i := 0; i < len(s)+1; i++ {
        dp[i][0] = 0
    }
    for i := 0; i < len(t)+1; i++ {
        dp[0][i] = 0
    }
    for i:= 1; i <= len(s); i++ {
        for j := 1; j <= len(t); j++ {
            if s[i-1] == t[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            }else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    if dp[len(s)][len(t)] ==len(s) {
        return true
    }else {
        return false
    }  
}
func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
~~~

#### 15.[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

 给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*。你需要让组成和的完全平方数的个数最少。 

```
输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
```

```
输入: n = 13
输出: 2
解释: 13 = 4 + 9.
```

~~~go
func numSquares(n int) int {
  dp  := make([]int, n+1)

    for i := 1; i < n+1; i++ {
        dp[i] = i

        for j := 1; i - j*j >= 0; j++ {
            dp[i] = min(dp[i], dp[i-j*j]+1)
        }
    }
    return dp[n]
}

func min(x, y int) int {
    if x > y {
        return y
    }
    return x
}
~~~

#### 16.[礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

~~~go
//在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
func maxValue(grid [][]int) int {
    dp := make([][]int, len(grid))
    for i := 0; i < len(grid); i++ {
        dp[i] = make([]int, len(grid[0]))
    }

    dp[0][0] = grid[0][0]

    for i:= 0; i < len(grid); i++ {
        for j:= 0; j < len(grid[0]); j++ {
            if i != 0 && j == 0{
                dp[i][j] = dp[i-1][j] + grid[i][j]
            }else if i == 0 && j != 0 {
                dp[i][j] = dp[i][j-1] + grid[i][j]
            }else if i != 0 && j != 0 {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]
            }
        }
    }
    return dp[len(grid)-1][len(grid[0])-1]
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
~~~

#### 17.[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

~~~go
//你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
//给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    dp := make([]int, len(nums)+1)
    dp[0] = 0
    dp[1] = nums[0]

    for i := 2; i < len(nums)+1; i++ {
        dp[i] = max(dp[i-1], dp[i-2]+nums[i-1])
    }
    return dp[len(nums)]
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
~~~



###4.二叉树所有题目

#### 1.[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

#### 2.[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

#### 3.[114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

#### 4.[654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

#### 5.[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

#### 6.[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

#### 7.[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

#### 8.[700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

#### 9.[701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

#### 10.[538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

#### 11.[450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

#### 12.[剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

#### 13.[剑指 Offer 55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

#### 14.[剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

#### 15.[剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

#### 16.[剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

#### 17.[剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

#### 18[剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

#### 19[剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

###5.广度优先做过的题

#### 1.[1162. 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)

#### 2.[994. 腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges/)

#### 3.[剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

#### 4.[1091. 二进制矩阵中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)

~~~go
//广度优先
func shortestPathBinaryMatrix(grid [][]int) int {
    
    if grid[0][0] != 0 {
        return -1
    }
    queue := []*point{&point{0, 0}}
    m := len(grid)
    n := len(grid[0])
    if m == 1 {
        return 1
    }
    dx := []int{0, -1, -1, -1, 0, 1, 1, 1}
    dy := []int{1, 1, 0, -1, -1, -1, 0, 1}

    for len(queue) != 0{
        curPoint := queue[0]
        queue = queue[1:]
        for i := 0; i < 8; i++ {
            newX := curPoint.x + dx[i]
            newY := curPoint.y + dy[i]

            if newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] == 0 {
                queue = append(queue, &point{newX, newY})
                grid[newX][newY] = grid[curPoint.x][curPoint.y] + 1
                if newX == m -1 && newY == n -1 {
                    return grid[m-1][n-1] +1
                }
            }
        }
    } 
    return -1
}
type point struct{
    x int
    y int
}
~~~



###6.深度优先做过的题

#### 1.[剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子

~~~go

func exist(board [][]byte, word string) bool {

    b := []byte(word)
    for i := 0; i < len(board); i++ {
        for j := 0; j < len(board[0]); j++ {

            if  dfs(i, j, 0, b, board) {
                return true
            }
        }
    }
    return false
}

func dfs(i, j, key int, word []byte, board [][]byte) bool {


    if i < 0 || i >= len(board) || j < 0 || j >= len(board[0]) || word[key] != board[i][j] {
        return false
    }

    if key == len(word)-1 {
        return true
    }
    temp := board[i][j]
    board[i][j] = '*'
    flag := dfs(i+1, j, key+1, word, board) || dfs(i-1, j, key+1, word, board) || dfs(i, j+1, key+1, word, board) || dfs(i, j-1, key+1, word, board)
    board[i][j] = temp
    return flag
}
~~~

#### 2.[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

~~~go
func numIslands(grid [][]byte) int {
    m := len(grid)
    n := len(grid[0])
    count := 0
    for i := 0; i < m; i++ {
        for j := 0; j< n; j++ {
            if grid[i][j] == '1' {
                dfs(grid, i, j)
                count++
            }
        }
    }
    return count
}

func dfs(grid [][]byte, x, y int) {
    m := len(grid)
    n := len(grid[0])
    if x < 0 || x == m || y < 0 || y == n || grid[x][y] != '1' {
        return 
    } 
    grid[x][y] = '0'
    dx := []int{0, 0, 1, -1}
    dy := []int{1, -1, 0, 0}

    for i := 0; i < 4; i++ {
        newX := x + dx[i]
        newY := y + dy[i]

        dfs(grid, newX, newY)
    }
}
~~~

#### 3.[695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

给定一个包含了一些 0 和 1 的非空二维数组 grid 。

一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)

~~~go
func maxAreaOfIsland(grid [][]int) int {
    m := len(grid)
    n := len(grid[0])
    var res int
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            res = max(res, dfs(grid, i, j))
        }
    }
    return res
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}

func dfs(grid [][]int, x, y int) int {
    m := len(grid)
    n := len(grid[0])

    if x < 0 || x == m || y < 0 || y == n || grid[x][y] != 1 {
        return 0
    }
    grid[x][y] = 0
    ans := 1

    ans += dfs(grid, x+1, y)
    ans += dfs(grid, x-1, y)
    ans += dfs(grid, x, y+1)
    ans += dfs(grid, x, y-1)
    return ans
}
~~~

#### 4.[257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]
```

~~~go
给定一个二叉树，返回所有从根节点到叶子节点的路径。
说明: 叶子节点是指没有子节点的节点。

/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func binaryTreePaths(root *TreeNode) []string {
    res = []string{}
    if root == nil {
        return res
    }
    backTrace(root, "")
    return res
}
var res []string
func backTrace(root *TreeNode, path string) {
    if root == nil {
        return
    }
    if root.Left == nil && root.Right == nil {
        path = path + strconv.Itoa(root.Val)
        res = append(res, path)
        return
    }
    path +=strconv.Itoa(root.Val)+  "->"
    backTrace(root.Left, path)
    backTrace(root.Right, path)
    // path = path[:len(path)-3]
}
~~~



###7.二分法

#### 1.[744. 寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)

~~~go
func nextGreatestLetter(letters []byte, target byte) byte {
//二分法是一种特殊的双指针 通过mid = (left+right)/2 通过target和mid大小根据实际情况判断left=mid 或 left = mid + 1 或 left = mid - 1  或 right = mid 或 right = mid -1 或 right = mid + 1
// 对于 left < right 时 终止条件为 left == right
// 对于 left <= right时 终止条件为 left > right (left+1 == right)
    left := 0
    right := len(letters) - 1
    if target >= letters[right] {
        return letters[0]
    }

    for left < right {
        mid := (left + right) >> 1

        if target < letters[mid] {
            right = mid
        }else {
            left = mid+1
        }
    }
    return letters[right]
}
~~~

#### 2.[540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

~~~go
//对于这道题，运用了一个技巧，当mid为偶数时， 有两种情况 mid == mid + 1 那么 解一定在右侧 此时 left = mid + 2
//否则 解在左侧 注意： 此时 right = mid - 1 而不是 - 2

func singleNonDuplicate(nums []int) int {
    if len(nums) == 0{
        return 0
    }
    left := 0
    right := len(nums) - 1

    for left < right {
        mid := (left +right) >> 1
        if mid % 2 == 1 {
            mid--
        }

        if nums[mid] == nums[mid+1] {
            left = mid + 2
        }else {
            right = mid - 1
        }
    }
    return nums[left]
}
~~~

#### 3.[278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)

~~~go
//本题可理解为 前面是一个slice t, t, t, t, f, f, f 找到第一个false
func firstBadVersion(n int) int {
    l := 0
    r := n
    for r > l {
        mid := (l + r)/2

        if !isBadVersion(mid) {
            l = mid+1
        }else {
            r = mid
        }
    }
    return l
}
~~~

#### 4.旋转数组几道题（二分法）

1. #### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

~~~go
package dichotomy

import "fmt"
// 在旋转数组中找到target 注意 left <= right  left 有等于 right 的情况
func Search(nums []int, target int) int {
	left := 0
	right := len(nums) - 1

	for left <= right {
		mid := (left + right)/2
		fmt.Println("left, right, mid  : ", left, right, mid)
		if nums[mid] == target {
			return mid
		}

		if nums[mid] >= nums[left] {
			if target >= nums[left] && target <= nums[mid] {
				right = mid
			}else{
				left = mid + 1
			}
		}else{
			if target >= nums[mid] &&target <= nums[right] {
				left = mid + 1
			}else {
				right = mid
			}
		}
	}
	return -1
}
~~~

2. #### [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

~~~go
func findMin(nums []int) int {
    left := 0
    right := len(nums) - 1
    for left <= right {
        if nums[left] <= nums[right] {
            return nums[left]
        }
        mid := (left + right)/2
        
        //[left, mid] continue
        if nums[left] <= nums[mid] {
            left = mid + 1
        }else{
            right = mid
        }

    }
    return -1
}
~~~

3. #### [81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

#### 5.[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

~~~go
//特别的一道题
func searchInsert(nums []int, target int) int {
    left := 0
    right := len(nums) - 1
    ans := len(nums)
    for left <= right {
        mid := (left + right) / 2
        if target <= nums[mid] {
            ans = mid
            right = mid - 1
        }else {
            left = mid + 1
        }
    }
    return ans
}
~~~



### 8.贪心算法

#### 1.[435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

~~~go
//将队尾排序 找到离队尾最近的下一个队首 循环整个slice
func eraseOverlapIntervals(intervals [][]int) int {
	if len(intervals) == 0 {
        return 0
    }
    sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][1] < intervals[j][1]
	})

	xEnd := intervals[0][1]
	count := 1
	for _, v := range intervals {
		if xEnd <= v[0] {
			count++
			xEnd = v[1]
		}
	}
	return len(intervals) - count
}
~~~

#### 2.[452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

~~~go
//和435一样，求最少需要的个数 也就是 所有不重叠的 线段
func findMinArrowShots(points [][]int) int {
    if len(points) == 0 {
        return 0
    }
    sort.Slice(points, func(i, j int)bool {
        return points[i][1] < points[j][1]
    })

    xEnd := points[0][1]
    count := 1
    for i := 1; i < len(points); i++ {
        if xEnd < points[i][0] {
            xEnd = points[i][1]
            count++
        }
    }
    return count
}
~~~

#### 3.[605. 种花问题](https://leetcode-cn.com/problems/can-place-flowers/)

~~~go
//贪心算法， 判断条件为 i== 0 并且 i-1==0 || i== 0  并且 i== len(flower)-1 || i+1 == 0

func canPlaceFlowers(flowerbed []int, n int) bool {
    count := 0
    for i := 0; i < len(flowerbed); i++ {
        if flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == len(flowerbed) - 1 || flowerbed[i+1] == 0) {
            flowerbed[i] = 1
            count++
        } 
    }
    return count >= n 
}
~~~

#### 4.[665. 非递减数列](https://leetcode-cn.com/problems/non-decreasing-array/)

~~~go
//这道题的重点在于 i-2 和 i的关系  如果 i-2 大于 i 那么要 i = i -1 正常情况是 i-1 = i
func checkPossibility(nums []int) bool {
    for i := 1; i < len(nums); i++ {
        if nums[i] < nums[i-1] {
            if i - 2 >= 0 && nums[i-2] > nums[i] {
                nums[i] = nums[i-1]
                break
            }else {
                nums[i-1] = nums[i]
                break
            }
        }
    }
    for i := 0; i < len(nums)-1; i++ {
        if nums[i] > nums[i+1] {
            return false
        }
    }
    return true
}
~~~

#### 5.[763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/)

~~~go
func partitionLabels(s string) (partition []int) {
    lastPos := [26]int{}
    for i, c := range s {
        lastPos[c-'a'] = i
    }
    start, end := 0, 0
    for i, c := range s {
        if lastPos[c-'a'] > end {
            end = lastPos[c-'a']
        }
        if i == end {
            partition = append(partition, end-start+1)
            start = end + 1
        }
    }
    return
}
~~~

### 9.分治算法

#### 1.[241. 为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)

~~~go
func diffWaysToCompute(input string) []int {
    
    if isDig(input) {
        tmp, _ := strconv.Atoi(input)
        return []int{tmp}
    }
    
    res := []int{}
    for i, s := range input {
        tmpC := string(s)
        if tmpC == "+" || tmpC == "-" || tmpC == "*" {
            left := diffWaysToCompute(input[:i])
            right := diffWaysToCompute(input[i+1:])

            for _ , leftR := range left {
                for _, rightR := range right {
                    var res2 int
                    if tmpC == "+" {
                        res2 = leftR + rightR
                    }else if tmpC == "-" {
                        res2 = leftR - rightR
                    }else {
                        res2 = leftR * rightR
                    }
                    res = append(res, res2)
                }
            }
        }
    }
    return res
}

func isDig(s string) bool {
     _, err := strconv.Atoi(s)
    if err != nil {
        return false
    }
    return true
}
~~~

#### 2.[95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

~~~go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func generateTrees(n int) []*TreeNode {
    if n == 0 {
        return nil
    }
    return helper(1, n)
}

func helper(start, end int) []*TreeNode {
    res := []*TreeNode{}

    if  end < start {
        return []*TreeNode{nil}
    }

    for i := start; i <= end; i++ {
        lefts := helper(start, i-1)
        rights := helper(i+1, end)

        for _, leftTree := range lefts {
            for _, rightTree := range rights {
                curTree := &TreeNode{i, nil, nil}
                curTree.Left = leftTree
                curTree.Right = rightTree
                res = append(res, curTree)
            }
        }
    }
    return res
}
~~~

### 10.数学部分

#### 1.[204. 计数质数](https://leetcode-cn.com/problems/count-primes/)

~~~go
func countPrimes(n int) int {
    m := map[int]bool{}

    for i := 2; i < n; i++ {
        m[i] = true
    }

    for i := 2; i < n; i++ {
        if m[i] {
            for j :=i*i; j < n; j += i {
                m[j] = false
            }
        }
    }
    var count int
    for i := 2; i < n; i++ {
        if m[i] {
            count++
        }
    }
    return count
}
~~~

#### 2.[172. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

~~~go
//找到阶乘中每个数中5的个数
func trailingZeroes(n int) int {
    var res int
    for i := 0; i <= n; i++ {
        N := i
        for N > 0 {
            if N % 5 == 0 {
                res++
                N = N / 5
            }else{
                break
            }
        }
    }
    return res
}
~~~

####3.[67. 二进制求和](https://leetcode-cn.com/problems/add-binary/)

这道题是**重点**  主要为了学习 **big包**的使用

~~~go

func addBinary(a string, b string) string {

	ai, _ := new(big.Int).SetString(a, 2)
	bi, _ := new(big.Int).SetString(b, 2)

	ai.Add(ai, bi)
	return ai.Text(2)
}
~~~

#### 4.[415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)

~~~go
func addStrings(num1 string, num2 string) string {

    add := 0
    ans := ""
    for i, j := len(num1)-1, len(num2)-1; i >= 0 || j >= 0 || add != 0; i, j = i-1, j-1 {
        var x, y int
        if i >= 0{
            x = int(num1[i] - '0')
        }
        if j >= 0 {
            y = int(num2[j] - '0')
        }

        res := x + y + add

        ans = strconv.Itoa(res%10) + ans
        add = res / 10

    }
    return ans
}
~~~

#### 5.[367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

~~~go
//利用1+3+5+...+2n-1 = n²
func isPerfectSquare(num int) bool {
    j := 1

    for num > 0 {
        num = num - j
        j = j+ 2
    }

    if num == 0 {
        return true
    }else{
        return false
    }
}
~~~

##7.golang面试积累

###1.常见面试题



1.  对于`func add(args ...int) int {}`调用方式正确的选项有（ABD）
   A. add(1, 2)
   B. add(1, 3, 7)
   C. add([] int{1, 2})
   D. add([] int{1, 3, 7}...) 

2. 变量的初始化，下面正确的使用方式是（ABC）
   A. var i int = 10
   B. var i = 10
   C. i := 10
   D. i = 10 

3. golang 中的引用类型包括（BCD）
   A. string
   B. map
   C. channel
   D. interface 

4. 关于整型切片的初始化，下面正确的是（BCD）
   A. s := make([] int)
   B. s := make([] int, 0)
   C. s := make([] int, 5, 10)
   D. s := [] int{1, 2, 3, 4, 5} 

5. 关于 channel，下面语法正确的是（ABC）
   A. var ch chan int
   B. ch := make(chan int)
   C. <- ch
   D. ch <- 

6. 关于无缓冲和有缓冲的 channel，下面说法正确的是（D）
   A.无缓冲的 channel 是默认的缓冲为 1 的 channel
   B.无缓冲的 channel 和有缓冲的 channel 都是同步的
   C.无缓冲的 channel 和有缓冲的 channel 都是非同步的
   D.无缓冲的 channel 是同步的，而有缓冲的 channel 是非同步的 

7. 简述变量逃逸

   答： 逃逸分析是编译器在静态编译的时候，分析对象的生命周期及引用情况来决定对象内存分配到堆上还是栈上，由栈内存分配较快于堆且栈内存回收较快（无需gc），编译器以此来性能优化程序

8. 简要描述slice在append时发生了什么

   答：先看cap是否可以装下添加的元素， 如果够， 则直接添加 如果不够 则判断现在slice大小， 大于 1024 则扩容1.25倍 不够在扩容1.25倍 如果小于1024， 则扩容两倍

9. 给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那俩个整数，并返回他们的数组下标

   leetcode: https://leetcode-cn.com/problems/two-sum/solution/

   ~~~go
   func twoSum(nums []int, target int) []int {
   
       var res []int
       m := make(map[int]int)
       for i, k := range nums {
           if v, exist := m[target - k]; exist {
               res = append(res, v)
               res = append(res, i)
           }
           m[k] = i
       }
       return res
   }
   ~~~

10. 给定两个数组，编写一个函数来计算他们的交集，以及差集

  ~~~go
  func intersection(nums1 []int, nums2 []int) []int {
          m := make(map[int]bool)
          var res []int
          for _, i := range nums1 {
              m[i] = true
          }
  
          for _, i := range nums2 {
              if m[i] == true {
                  res = append(res, i)
                  m[i] = false
              }
          }
          return res
  }
  //A={1,2,3,4,5} B={1,2,3,6} 差集B-A={6} 
  //补集：属于全集U不属于集合A的元素组成的集合称为集合A的补集，记作CuA，即CuA={x|x∈U,且x不属于A}。
  ~~~

11. 简单谈下defer的应用场景及注意事项

    答：关闭文件 网络请求等 先进后出

12. 简单谈下chan的应用场景及注意事项

    参考文章： https://segmentfault.com/a/1190000017958702

    通道是可以让一个goroutine发送特定值到另一个goroutine的通信机制。

    使用场景：

    - 限制并发量

    ~~~go
    var token = make(chan struct{}, 20)
    func crawl(url string) []string {
        fmt.Println(url)
        tokens <- struct{}{}
        list, err := links.Extacts(url)
        <- tokens
        if err != nil {
            
        }
        return list
    }
    ~~~

    - 结合select 实现多路复用

    ~~~go
    abort := make(chan struct{})
    select{
        case <- time.After(0 * time.Second):
        case <- abort:
        fmt.Println("aborted")
        return
    }
    lanch()
    ~~~

    - 消息传递、消息过滤
    - 信号广播
    - 事件订阅与广播
    - 请求、响应转发
    - 任务分发等

    channel存在三种状态：

    - nil， 未初始化的状态
    - active，正常的channel
    - closed，已经关闭

    | 场景                   | 读取             | 写入       | 关闭  |
    | ---------------------- | ---------------- | ---------- | ----- |
    | 未初始化chan           | 死锁（deadlock） | 死锁       | panic |
    | 已初始化chan（无缓冲） | 看具体代码       | 看具体代码 | 正常  |
    | 已初始化chan（有缓冲） | 看具体代码       | 看具体代码 | 正常  |
    | 已关闭chan             | 正常             | panic      | panic |

13. 简述线程，进程，协程的含义及区别

    答：https://mp.weixin.qq.com/s/kcsvBr08wcxGYWE9vPC0QQ

14. 往一个对象里写入 10w 条数据，怎样保证数据的准确性 

    答：chan mutex等 使用多线程 waitgroup等

15. 闭包的注意事项

    ~~~go
    var funcSlice []func()
    for i := 0; i < 3; i++ {
    	funcSlice = append(funcSlice, func() {
    		println(i)
    	})
    
    }
    for j := 0; j < 3; j++ {
    	funcSlice[j]() // 3, 3, 3
    }
    ~~~

    输出序列为 **3, 3, 3**。

    看了前面的例子之后这里就容易理解了： 这三个函数引用的都是同一个变量（`i`）的地址，所以之后 `i` 递增，解引用得到的值也会递增，所以这三个函数都会输出 **3**。

    ```go
    var funcSlice []func()
    for i := 0; i < 3; i++ {
    	println(&i) // 0xc0000ac1d0 0xc0000ac1d0 0xc0000ac1d0
    	funcSlice = append(funcSlice, func() {
    		println(&i)
    	})
    
    }
    for j := 0; j < 3; j++ {
    	funcSlice[j]() // 0xc0000ac1d0 0xc0000ac1d0 0xc0000ac1d0
    }
    ```

    可以看到三个函数引用的都是 `i` 的地址。

    **解决办法：**

    将参数显式传递进去

    ~~~go
    var funcSlice []func()
    for i := 0; i < 3; i++ {
    	func(i int) {
    		funcSlice = append(funcSlice, func() {
    			println(i)
    		})
    	}(i)
    
    }
    for j := 0; j < 3; j++ {
    	funcSlice[j]() // 0, 1, 2
    }
    ~~~

16. **简单介绍interface的应用场景**

     参考文章：https://studygolang.com/articles/20433

     ​					https://segmentfault.com/a/1190000022268243

     interface在golang中可理解为一种类型的规范或者约定，golang的interface不需要显式说明实现了某个接口。只需要通过约定的形式，隐式的实现interface中的方法即可。

     理解go的interface只需记住三点：

     - interface是方法声明的集合
     - 任何类型的对象实现了在interface接口中声明的全部方法，则表明该类型实现了该接口
     - interface可以作为一种数据类型，实现了该接口的任何对象都可以给对应的接口类型变量赋值

     两点注意：

     - interface可以被任意对象实现，一个类型/对象也可以实现多个interface
     - 方法不能重载，如 eat（） eat（s string）不能同时存在

     ~~~go
     
     type Phone interface {
     	call()
     }
     type NPhone struct {
     
     }
     
     func (n NPhone)call()  {
     	fmt.Println("i am N i call now")
     }
     
     type APhone struct {
     
     }
     func (a APhone)call() {
     	fmt.Println("i am A i call now")
     }
     
     func main() {
     	var p Phone
     	p = new(NPhone)
     	p.call()
     	p = new(APhone)
     	p.call()
     }
     ~~~

     上述体现了interface接口的语法，在main函数中，也体现了多态的特性 

     **面向对象的开闭原则**

     - 平铺式的模块设计

     作为interface数据类型，更多是满足一些面向对象的编程思想。软件设计的最高目标是高内聚，低耦合。其中一个叫做开闭原则。看一个例子

     ~~~go
     package main
     
     import "fmt"
     
     //我们要写一个类 Banker是银行业务员
     type Banker struct {
     }
     //存款
     func (b *Banker)Save() {
     	fmt.Println("存款")
     }
     //转账业务
     func (b *Banker)Tranfer() {
     	fmt.Println("转账")
     }
     //支付业务
     func (b *Banker)Pay(){
     	fmt.Println("支付")
     }
     
     func main() {
     	b := Banker{}
     	b.Save()
     	b.Tranfer()
     	b.Pay()
     }
     /*
     现在随着我们的程序越写越复杂，银行业务员可能就要增加方法，会导致业务员模块越来越臃肿
     这样的设计会导致当我们给Banker添加新的业务时候，会直接修改banker代码，那么banker
     模块功能越来越多 目前问题是耦合度太高。banker的职责不够单一 代码的维护成本随着业务的复杂
     正比成倍增加
      */
     ~~~

     - 开闭原则设计

     那么，如果我们使用interface 制作一个抽象banker模块，然后提供一个抽象的方法。分别根据这个抽象模块，去实现 支付、转账、存款

     当我们增加一个功能时，无论成功与否都不会影响之前的系统

     ~~~go
     type AbsBanker interface {
     	DoBusi() //抽象的处理业务接口
     }
     //存款业务员
     type SaveBanker struct{}
     func (sb *SaveBanker) DoBusi(){
     	fmt.Println("存款")
     }
     //转账业务员
     type TranferBanker struct {}
     func (tb *TranferBanker) DoBusi(){
     	fmt.Println("转账")
     }
     //支付业务员
     type PayBanker struct {}
     func (pb *PayBanker)DoBusi(){
     	fmt.Println("支付")
     }
     func main(){
     	sb := &SaveBanker{}
     	sb.DoBusi()
     	tb := &TranferBanker{}
     	tb.DoBusi()
     	pb := &PayBanker{}
     	pb.DoBusi()
     }
     ~~~

     开闭原则：一个软件实体类、模块和函数应该对扩展开放，对修改关闭。简单说就是改进需求时，应该尽量通过扩展来实现变化，我不是通过修改已有代码来实现变化。

     **接口的意义**

     使用接口是实现多态的思想，就是我们可以根据interface类型来设计API接口。那么这种API接口的适应能力不仅能适应当下所实现的全部模块，也能适应未来实现的模块来进行调用。

     **面向对象的依赖倒转原则**

     - 耦合度极高的模块设计关系

     ~~~go
     type Benz struct {}
     func (b *Benz)Run(){
     	fmt.Println("benz is running")
     }
     
     type BMW struct {
     
     }
     func(bm *BMW)Run(){
     	fmt.Println("bmw is running")
     }
     type zhangsan struct {
     
     }
     
     func (z *zhangsan)Dbenz(benz *Benz){
     	fmt.Println("zhangsan drive benz")
     	benz.Run()
     }
     
     func (z *zhangsan)Dbmw(bmw *BMW){
     	fmt.Println("zhangsan drive bmw")
     	bmw.Run()
     }
     
     type leesi struct {
     
     }
     
     func (l *leesi)Dbenz(benz *Benz){
     	fmt.Println("leesi drive benz")
     	benz.Run()
     }
     
     func (l *leesi)Dbmw(bmw *BMW){
     	fmt.Println("leesi drive bmw")
     	bmw.Run()
     }
     
     func main(){
     	//业务1 张三开奔驰
     	benz := &Benz{}
     	z3 := &zhangsan{}
     	z3.Dbenz(benz)
     
     	//业务2 李四开宝马
     	bmw := &BMW{}
     	l4 := &leesi{}
     	l4.Dbmw(bmw)
     }
     ~~~

     上面的设计虽然实现功能，但问题在于小规模没问题，但一旦程序需要扩展， 比如我们增加丰田，大众等，那么模块与模块的依赖关系将指数级增加

     - 面向抽象层依赖倒转

     将业务分为抽象层，实现层，业务逻辑层 将抽象层的模块接口定义出来，然后依照抽象层去实现实现层的模块，在我们写实现层代码时，实际上我们只需要参考对应的抽象层实现就好了，实现每个模块，和其他模块没有关联。这样我们实现每个模块只依赖对象的接口，而和其他模块没有关系，依赖关系单一。

     业务逻辑同样如此，只需要参考抽象层的接口来实现就好

     我们将这样的设计原则叫做 **依赖倒转原则**

     修改上面的代码：

     ~~~go
     /*********抽象层*********/
     type Car interface{
     	Run()
     }
     type Driver interface {
     	Drive(car Car)
     }
     /*********实现层*********/
     type Benz struct {
     
     }
     func (b *Benz) Run(){
     	fmt.Println("benz is running")
     }
     
     type BMW struct {
     
     }
     func (b *BMW)Run(){
     	fmt.Println("BMw is running")
     }
     
     type z3 struct {
     
     }
     func (z *z3)Drive(car Car){
     	fmt.Println("z3 drive car")
     	car.Run()
     }
     
     type Lee4 struct {
     
     }
     func (l *Lee4)Drive(car Car){
     	fmt.Println("l4 drive car")
     	car.Run()
     }
     /*********业务逻辑层*********/
     func main(){
     	//***z3 drive BMW
     	var car Car
     	car = &BMW{}
     	var driver Driver
     	driver = &z3{}
     	driver.Drive(car)
         
     	//***li4 drive benz
     	var benz Car
     	benz = &Benz{}
     	var li4 Driver
     	li4 = &Lee4{}
     	li4.Drive(benz)
     }
     ~~~

17. 反射（华为面试时的提问）

    答：https://studygolang.com/articles/13178

18. 断言（华为面试时的提问）

    答：golang中所有类型都实现了interface{}空接口，所以通常将它作为函数参数或者结构体字段，已实现对类型的抽象。

19. go的引用类型和值类型
    - 引用类型： 指针，slice， channel， 接口interface， map， 函数
    - 值类型： int， float， boolean， string， 数组， <u>*结构体*</u>

21. 字节跳动笔试题（go）

以下代码有什么问题，怎么解决

~~~go
total, sum
for i := 0; i < 11; i++ {
    sum += i
    go func () {
        total += i
    }()
}
fmt.Println(total, sum)
~~~

- ==考点1==

  上面的i的值被所有的匿名函数值共享并且被后序的迭代所更新。这时新的goroutine执行字面量函数，for循环可能已经更新i，并且开始另一个迭代或者已经完全结束，所以当这些goroutine读取i的值时，他们所看到的都是i的最后一个值。通过添加显式参数，可以确保当go语句执行的时候，使用的是当前的i值。

~~~go
for i:= 0; i < 11; i++ {
    go func (i int) {
        fmt.Println(i)
    }(i)
}
time.Sleep(time.Second)
~~~

- 考点2

  data race问题（可以通过加锁解决）验证用go run -race main.go

~~~go
var mutex sync.Mutex
total, sum := 0, 0
for i:= 0; i < 11; i++ {
    sum += i
    go func (i int){
        mutex.Lock()
        total += i
        mutex.Unlock()
    }(i)
}
~~~

​	也可是使用atomic包解决

~~~go
var total int64
sum := 0
for i:= 0; i < 11; i++ {
    go func (i int){
        atomic.AddInt64(&total, int64(i))
    }(i)
}
~~~

- 考点3

  go协程先于主线程结束问题，解决此问题需要需要使用sync.WaitGroup

~~~go
func main() {
	var wg sync.WaitGroup
	var total int32
	sum := 0

	for i := 1; i <= 10; i++ {
		wg.Add(1)
		sum += i
		go func(i int) {
			defer wg.Done()
			atomic.AddInt32(&total, int32(i))
		}(i)
	}
	wg.Wait()
	fmt.Println(total, sum)
}
~~~

22. **==go面试题（最全版）==**

    https://blog.csdn.net/itcastcpp/article/details/80462619

### 2.tcp网络调优

#### 1.TFO原理和设置

TCP快速打开是一种对TCP简化握手手续的扩展，用于提高两端点间连接的打开速度。简而言之，就是在tcp的三次握手过程中传输实际有用的数据。

它通过握手开始时SYN包中的TFO cookie 来验证一个之前连接过的客户端。如果验证成功，他可以在三次我握手最终的ACK包收到之前就开始发送数据。这个加密的cookie被存储在客户端，在一开始的连接时被设定好。

- 普通的TCP三次握手过程

![](image\net\TCPthreehandshake.jpg)

- TFO的连接过程

![](image\net\TFOhandsha1.jpg)

- 当一个客户端断开一段时间后，再次连接过程

![](E:\devopsdocs\image\net\TFOhandsha2.jpg)

- 开启TFO

~~~shell
echo 3 > /proc/sys/net/ipv4/tcp_fastopen
#3代表开启TFO客户端和服务器端
#1表示开启客户端 2表示开启服务器端
~~~

### 3.TCP半连接和全连接syncookies用法

- 半连接队列也称为SYN队列
- 全连接队列也称为accept队列

服务器收到客户端的SYN请求后，内核会把该连接存储到SYN队列中，并向客户端相应SYN+ACK 当客户端返回ACK时，内核会把连接从SYN队列中移除，创建一个新的完全的连接 并将其加入到accept队列 等待进程调用accept函数把连接取出来 

![](image\net\halflinkandcompletelink.jpg)



不管是SYN队列还是accept队列，都有最大长度限制，超出限制 内核会直接丢弃 或返回RST包

~~~shell
ss -lnt
#但需要注意的是 ss 命令获取的 Recv-Q/Send-Q 在「LISTEN 状态」和「非 LISTEN 状态」所表达的含义是不同的
~~~

~~~shell
cat /proc/sys/net/ipv4/tcp_abort_on_overflow
0
~~~

- 0：直接丢弃
- 1：如果全连接队列满了，server向客户端发送reset包，表示废掉这个握手过程和这个连接

**增大TCP全连接最大值取决于somaxconn和backlog之间的最小值 min（somaxconn, backlog）**

1. 增大somaxconn

~~~shell
echo 5000 > /proc/sys/net/core/somaxconn
~~~

2. 增大backlog： nginx中backlog默认值是511

~~~shell
server{
		listen 8080 default backlog=5000;
		server_name localhost;
		...
}
~~~

**增大TCP半连接不止要修改max_syn_backlog 还关系到 somaxconn和backlog**

- 当 max_syn_backlog > min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log = min(somaxconn, backlog) * 2;
- 当 max_syn_backlog < min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log = max_syn_backlog * 2;

~~~shell
echo 256 > /proc/sys/net/ipv4/tcp_max_syn_backlog
echo 128 > /proc/sys/net/core/somaxconn
~~~

问题：如果SYN半连接队列已满，只能丢弃连接吗？

答：开启syncookies功能就可以在不使用SYN半连接队列的情况下成功建立连接

建立过程： 服务器根据当前状态计算出一个值，放在己方发出的ACK+SYN报文中发出，当客户端返回ACK报文时，取出该值验证，如果合法 就认为连接建立成功

syncookies参数主要有三个值

- 0 表示关闭该功能
- 1 表示仅当SYN半连接放不下时，再启用他
- 2 便是无条件开启

~~~shell
echo 1 > /proc/sys/net/ipv4/tcp_syncookies
~~~

防御SYN泛洪攻击的方法：

- 增大半连接队列

想要增大半连接队列，不能只单纯增大tcp_max_syn_backlog的值 还需增大somaxconn和backlog 也就是增大全连接队列  增大tcp_max_syn_backlogh和somaxconn修改linux内核参数

~~~shell
/proc/sys/net/ipv4/tcp_max_syn_backlog
/proc/sys/net/core/somaxconn
#backlog 在nginx.conf中
~~~

- 开启tcp_syncookie

~~~shell
/proc/sys/net/ipv4/tcp_syncookies
~~~

- 减少SYN+ACK重传次数

当服务器受到SYN攻击时，就会有大量处于SYN_REVC状态的TCP连接，处于这个状态的TCP会重传SYN+ACK，当重传次数超过设置的上线时 才会断开连接

那么针对SYN攻击的场景，我们可以减少ACK+SYN的重传次数 加快SYN_REVC状态的TCP连接断开

~~~shell
echo 1 > /proc/sys/net/ipv4/tcp_synack_retries
#SYN+ACK重传次数上限设置为1次
~~~

参考文献：https://www.cnblogs.com/xiaolincoding/p/12995358.html

### 4.linux TCP 收发包过程 ||  TCP哪些保证了数据传输的可靠性 

 序列号、确认重传、超时重传、拥塞控制

### 5. raft算法

==**Protocol Overview**==

- raft是实现分布一致性的协议
- 一个node有三种状态分别为
  - follower state
  - candidate state
  - leader state
- 所有节点初始阶段都是follower state
- 如果follower没有接收到leader的信息那么它将成为candidate
- candidate将向其他节点发起投票
- nodes将返回他们的投票
- 如果获得了多数票 这个candidate将成为新的leader
- 这个过程是 leader election
- 现在系统的所有更改都要经过领导

- 每一个更改都作为一个条目添加到节点日志（node's log）
- 此条目不提交前不会变更节点的值 ，为了提交条目，节点首先复制它到其他的Follower 节点， 然后leader等直到多数节点被写入条目，该条目现在提交给leader节点 节点状态发生变更，然后leader通知followers the个条目已经提交， 然后节点发生变更 此时系统是一致性的。这个过程叫做log replication

==**Leader Election**==

- 在raft中有两个控制选举的超时设置
- follower等待成为candidate的时间 选举超时一般为150ms到300ms，
- 选举超时后，follower将成为candidate开始新的选举任期，并且发起投票。
- 如果接受节点没有发起投票 那么它将投票给刚才发起投票的candidate，并且接受节点将重置选举超时。
- 一旦候选人获得多数票，它就成为领导者。
- 领导者开始向其追随者发送附加条目消息。
- 这些消息以==心跳超时==指定的间隔发送。
- 然后 follower响应每一个条目信息，这个election term将继续，直到follower停止接受心跳并成为candidate。
- 要求多数票保证每个任期只能选出一名领导人。如果两个节点同时成为候选人，那么就会发生分裂投票

==**Log Replication**==

- 一旦我们选出了一个领导者，我们就需要将系统的所有更改复制到所有节点
- 这是通过使用用于心跳的相同追加条目（append Entries）消息来完成的
- raft在网络隔离时也能保持一致性

参考文献（raft动画）：http://thesecretlivesofdata.com/raft/

### 5.一致性哈希

~~~shell
一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。
~~~

假设将哈希空间的点组成一个环（哈希值是32无符号整数）

![](image\hash\hashcircle.png)

整个空间按照顺时针组织 0 和 2^32-1在零点重合

//接下来，把服务器ip或者主机名作为关键字进行哈希，这样就能确定其在哈希环的位置

将主机均布在哈希环上

![](image\hash\hashcircle2.png)

使用哈希函数h计算值为key的数据在哈希环的具体位置， 根据计算得到的值 沿顺时针滚动，遇到第一台服务器就是其应该定位到的服务器

例如， ABCD四个要存储的对象，经过哈希运算后在环上的位置

![](image\hash\circle3.png)

根据一致性哈希算法，数据A在server1 B在server2 CD在server3上

**容错性和扩展性更好**



**增加虚拟节点可以解决数据倾斜问题**

当 系统有两台Redis 

![](image\hash\circle6.png)

这种情况会产生大量数据倾斜到server1 为了解决这个问题，可以使用虚拟节点 ， 即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点**称为虚拟节点** 



具体做法可以在服务器IP或主机名的后面增加编号来实现，例如上面的情况，可以为每个服务节点增加三个虚拟节点，于是可以分为 RedisService1#1、 RedisService1#2、 RedisService1#3、 RedisService2#1、 RedisService2#2、 RedisService2#3，具体位置如下图

![](image\hash\circle7.png)

对于数据定位的hash算法仍然不变，只是增加了虚拟节点到实际节点的映射。例如，数据C保存到虚拟节点Redis1#2，实际上数据保存到Redis1中。这样，就能解决服务节点少时数据不平均的问题。在实际应用中，通常将虚拟节点数设置为**32甚至更大**，因此即使**很少的服务节点**也能做到相对**均匀的数据分布**

参考文章：https://juejin.im/post/6844903750860013576

### 6.http1.0 1.1 HTTP2 http3 以及相关问题

####1.三个协议的演进过程

- http1.0 http1.1

http1.0采用短连接 会有较多的三次握手和四次挥手开销

支持管道传输 http1.0只有第一个响应回来才能发出这个请求，但是http1.1可以连续发送 并不需要等待其回来 减少了整体响应时间

- http1.1 性能瓶颈

1. 请求响应的头部没有经过压缩 只能压缩body部分
2. 发送冗长的首部，每次互相发送相同的首部造成浪费
3. 服务器按顺序响应，会出现队头拥塞
4. 没有请求优先级控制
5. 请求只能从客户端开始， 服务器只能被动响应

- http2

1. 采用hpack算法 避免传送相同的头部，并对头部数据进行压缩
2. 对传输的数据采用二进制方式，分为头部帧和数据帧
3. 对连接进行了复用， 只要访问同一个域名下的资源， 不必进行tcp连接的重新建立
4. 支持服务器push
5. 对服务器响应不会出现队头拥塞 可以根据优先级响应

- http3

1. 采用udp 

参考文章：

#### 2.http相关的状态码

**1XX**：请求已经接到，需要进一步处理

- 100  continue 大文件传输
- 101 协议升级使用
- 102 已经收到并处理请求 需要很长时间才能响应

**2XX**：成功处理请求

- 200 成功
- 201 create success
- 202 服务器接收请求 并处理请求 但未完成
- 203 当代理服务器修改了origin server的原始响应包体时 代理服务器修改200位203

**3XX**：重定向使用Location指定的资源或者缓存中的资源

- 300 资源有多种表述 通过300返回给客户端由客户端选择
- 301 资源永久重定向到另一个URI中
- 302 资源临时重定向
- 303 重定向到其他资源 常用于post和get方法的响应中
- 304 当前客户端拥有可能过期的缓存时，会携带缓存的标识etag 时间等信息询问服务器是否缓存可复用，而304告知客户端可复用
- 307 类似302
- 308 类似301

**4XX**：客户端错误

- 400 服务器认为客户端错误但不明确那种错误
- 401 用户认证缺失
- 403 forbidden
- 404 not found
- 410 Gone 服务器找不到资源 明确知道永久性找不到
- 405 服务器不支持请求method方法
- 408 服务器接受请求超时
- 409 资源冲突
- 411  Length Required

**5XX**：服务器端错误

- 500 服务器内部错误
- 502 bad gateway
- 504 gateway timeout

#### 3.http报文格式

http报文分为三部分： （状态行，响应行）start-line，消息报头（header），message-body(消息包体)

![](image\interview\httpform.png)



#### 4.http的请求方式（get post区别）

==**get**==： 主要获取信息方法，大量的性能优化都是针对该方法，幂等方法

==**HEAD**==：类似get方法，但服务器不发送body，用以获取HEAD元数据，幂等方法

==**POST**==：常用于提交form表单，新增资源

==**PUT**==：更新资源

==**DELETE**==：删除资源，幂等方法

==**TRACE**==：回显服务器收到的请求，用于定位问题。有安全风险

==**OPTIONS**==： 显示服务器对访问资源支持的方法，幂等方法

==**CONNECT**==： 建立tunnel隧道

#### 5.抓包post和get有什么区别

**GET**方法传参时，参数在状态行中传递，也就是在url中可以看到参数的传递。

**POST**方法传form表单时，参数在body中常用的一种方式是multi/form-data传递，分别为name和Data

### 7.多线程面试题

####1. 多线程顺序输出1-75

~~~go
package main

import (
	"fmt"
	"sync"
	"time"
)

var waiter sync.WaitGroup

func print5(i int) {
	j := i
	for j < i+5 {
		fmt.Println(j)
		j++
	}
	waiter.Done()
}

func main() {
	fmt.Println("Start print 75")
	waiter = sync.WaitGroup{}
	waiter.Add(15)

	for i := 1; i < 75; i += 5 {
		go print5(i)
		time.Sleep(1 * time.Nanosecond)
	}

	waiter.Wait()
	fmt.Println("End print 75")
}
~~~

#### 2. 两个协程交替打印1-100奇数偶数

~~~go
func go1(p chan int){
	for i := 1; i < 101; i++ {
		p <- i
		if i % 2 == 1 {
			fmt.Println("go1  : ", i)
		}
	}
}
func go2(p chan int) {
	for i := 1; i < 101;  i++{
		<- p
		if i % 2 == 0{
			fmt.Println("go2  : ", i)
		}
	}
}
func main() {
	msg := make(chan int)
	go go1(msg)
	go go2(msg)
	time.Sleep(time.Second*1)
}
~~~



### 8.golang中的锁 与 锁的基本知识

![](image\interview\lock1.jpg)

当已经有一个线程加锁后， 其他线程加锁则会失败，互斥锁和自旋锁对于加锁失败的处理方式是不一样的

- **互斥锁**加锁失败后，线程会释放cpu给其他进程
- **自旋锁**加锁失败后，线程会忙等待 直到它拿到锁

互斥锁加锁失败而阻塞的现象，是由操作系统内核实现 当加锁失败后， 内核将线程置位睡眠状态，等到锁被释放后，内核会在何时的时机唤醒线程，当这个线程成功获取锁后， 于是就可以继续执行 。

所以，互斥锁加锁失败后，会从用户态陷入内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本（两次线程上下文切换的成本）

- 当线程加锁失败时，内核会把线程的状态从运行状态设置为睡眠状态，然后把cpu切换给其他线程使用
- 接着，当锁被释放后，之前睡眠状态的线程会变成就绪状态，然后内核会在合适的时间，把cpu切换给该线程运行

**线程的上下文切换指**：当两个线程属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源保持不动，只需要切换线程的私有数据、寄存器等不共享的数据

自旋锁：自旋锁通过CPU提供的CAS函数（compare and Swap），在用户态完成加锁和解锁操作，不会主动产生线程的上下文切换，所以相比互斥锁来说，开销会小一些。

一般加锁会包括两个步骤：

- 查看锁的状态，如果锁是空闲的，则执行第二步
- 将锁设置为当前线程所有

CAS函数就把这两个步骤合并为一条硬件级指令 形成原子指令这样保证这两个步骤是不可分开的 必须一次性执行完成

使用自旋锁的时候 当发生多线程竞争锁的情况，加锁失败的线程会忙等待 直到它拿到锁

 这里的「忙等待」可以用 `while` 循环等待实现，不过最好是使用 CPU 提供的 `PAUSE` 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。 

读写锁：读写锁适用于明确区分读操作和写操作的场景

**读写锁原理**

- 当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。
- 但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。

 所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。 

**读写锁分为**：读优先锁、写优先锁、公平读写锁

**乐观锁和悲观锁**

互斥锁 自旋锁 读写锁都是悲观锁

 悲观锁做事比较悲观，它认为**多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁**。 

 乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作**。 

举例子：多人在线编辑文档   git提交代码

==**go中的锁**==

 go中提供了channel 同时也提供了传统的同步工具（包sync和sync/atomic）

==**go中的死锁**==

死锁是指两个或者两个以上的进程执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，他们将无法推进下去。此时称系统处于死锁状态或者系统产生了死锁

**死锁**：是“锁”的一种错误使用状态 应提前避免

**go中常见的死锁**：

- 同一个goroutine中，使用同一个channel读写

~~~go
package main

func main(){
    ch := make(chan int) // 这就是在main程中发生的死锁情况
    ch <- 6
    <- ch
}
~~~

- 2个以上的go程中，使用同一个channel通信。读写channel先于go程创建

~~~go
func main() {
    ch := make(chan int) 
    ch <- 666 //这里一直阻塞 不能向下运行
    go func () {
        <- ch //这里虽然创建了go程 但是上面会一直阻塞 不能运行到这里
    }
}
~~~

- 2个以上的go程中，使用多个channel通信， A go程获取channel1的同时，尝试使用channel2 ，同一时刻，B go程获取channel2的同时 尝试使用channel1

~~~go
func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    go func () { //匿名子 go程
        for {
            select { // 这里相互等对方造成死锁
                case <- ch1: // 这里ch1 欧数据读出才能执行下一句
                 ch2 <- 666
            }
        }
    }()
    
    for { //主go程
        select{
            case <- ch2 :   //这里ch2有数据读出才能执行下一句
              ch1 <- 888
        }
    }
}
~~~

- ~~在go语言中，channel和读写锁、互斥锁、尽量避免交叉使用~~

==互斥锁==

~~~go
var mutex sync.Mutex 
func write(){
    mutex.Lock()
    defer mutex.Unlock()
}
~~~

使用互斥锁解决任务编程问题

~~~go
func main() {
	go per1()
	per2()
	time.Sleep(time.Second)
}

func printer(s string) {
	for _, data := range s {
		fmt.Printf("%c", data)
	}
	fmt.Println()
}

func per1() {
	printer("hello")
}

func per2() {
	printer("world")
}
/*
输出
whello
orld
Process finished with exit code 0
*/

//加锁后
var mutex sync.Mutex
func main() {
	go per1()
	 per2()
	time.Sleep(time.Second)
}
func printer(s string) {
	mutex.Lock()
	defer mutex.Unlock()
	for _, data := range s {
		fmt.Printf("%c", data)

	}
	fmt.Println()
}
func per1() {
	printer("hello")
}
func per2() {
	printer("world")
}
/*
world
hello
Process finished with exit code 0
*/
~~~

==go读写锁==

读写锁可以让多个读并发，同时读取。但是写操作完全互斥的。go中读写锁为sync.RWMutex

一组是对写操作的锁定和解锁

~~~go
func (*RWMutex)Lock()
func (*RWMutex)Unlock()
~~~

另一组表示对读的锁定和解锁

~~~go
func (*RWMutex)RLock()
func (*RWMutex)RUnlock()
~~~

==读写锁示例==

~~~go
//写锁
var mutex sync.RWMutex
var count int
func main() {
	//for i := 0; i < 10; i++ {
	//	go read(i+1)
	//}
	for i := 0; i < 10; i++ {
		go write(i+1)
	}
	time.Sleep(time.Second*5)
}

func write(n int) {
	rand.Seed(time.Now().UnixNano())
	fmt.Printf("写go  %d 正在写数据。。。\n", n)
	mutex.Lock()
	num := rand.Intn(500)
	count = num
	fmt.Printf("写 go %d 写数据结束， 写入新值 %d\n", n, num)
	mutex.Unlock()
}

func read(n int) {
	mutex.RLock()
	defer mutex.RUnlock()
	fmt.Printf("读 go %d 正在读取数据。。。 \n", n)
	num := count
	fmt.Printf("读 go %d 读取数据结束， 读到 %d \n", n, num)
}
/*
go10 正在写数据。。。
go2 正在写数据。。。
go8 正在写数据。。。
go7 正在写数据。。。
go10 写数据结束， 写入新值 4
go6 正在写数据。。。
go1 正在写数据。。。
go3 正在写数据。。。
go4 正在写数据。。。
go9 正在写数据。。。
go2 写数据结束， 写入新值 4
go7 写数据结束， 写入新值 286
go8 写数据结束， 写入新值 142
go6 写数据结束， 写入新值 166
go5 正在写数据。。。
go1 写数据结束， 写入新值 4
go3 写数据结束， 写入新值 286
go4 写数据结束， 写入新值 142
go9 写数据结束， 写入新值 166
go5 写数据结束， 写入新值 370
*/
//在写锁中，当一个线程拿到锁后，一定会先完成写入数据并结束，从结果可以看出，如果A写开始先于B写开始，A写入数据结束也一定B写入结束
//读锁
	for i := 0; i < 10; i++ {
		go read(i+1)
	}
	//for i := 0; i < 10; i++ {
	//	go write(i+1)
	//}
/*
go2 正在读取数据。。。 
go10 正在读取数据。。。 
go6 正在读取数据。。。 
go6 读取数据结束， 读到 0 
go2 读取数据结束， 读到 0 
go7 正在读取数据。。。 
go7 读取数据结束， 读到 0 
go5 正在读取数据。。。 
go4 正在读取数据。。。 
go4 读取数据结束， 读到 0 
go9 正在读取数据。。。 
go9 读取数据结束， 读到 0 
go5 读取数据结束， 读到 0 
go10 读取数据结束， 读到 0 
go8 正在读取数据。。。 
go8 读取数据结束， 读到 0 
go1 正在读取数据。。。 
go1 读取数据结束， 读到 0 
go3 正在读取数据。。。 
go3 读取数据结束， 读到 0 
*/
//读锁是并行的，比如go2先于go6获取数据，但go6先于go2读取到数据
~~~

处于读锁定状态，那么针对他的写锁定操作永远不会成功，且相应的goroutine也会被一直阻塞。因为他们是互斥的

互斥锁的两种实现：https://www.jishuchi.com/read/go-interview/3440





### 9.进程 线程 协程

**进程**：进程是系统资源分配的最小单位，系统有一个个进程（程序）组成 包括文本区域、数据区域、堆栈区域

- 文本区域存储处理器执行的代码
- 数据区域存储变量和进程执行期间使用的动态分配的内存
- 堆栈区域存储着活动过程调用的指令和本地变量

因此进程的创建和销毁都是相对于系统资源。进程有三个状态：

- 等待态：等待某个事件完成
- 就绪态：等待系统分配处理器以便运行
- 运行态：占有处理器正在运行

通信问题：由于进程间是隔离的，各自拥有自己的内存资源，因此相对于线程是安全的，所以不同进程间通信只能通过IPC（inter process communication）进行通信共享

**线程**：

1. 线程属于进程
2. 线程共享进程的内存地址空间
3. 线程在进程内部可以通过全局变量进行通信 由此可以带来多个线程读写一个地址的情况 将带来不可预期的后果 因此引入了锁机制 例如互斥锁

- 线程是cpu调度的最小单位
- 进程是系统分配资源的最小单位

==线程和进程的上下文切换==

进程切换分为三步

1. 切换页目录以使用新的地址空间
2. 切换内核栈
3. 切换硬件上下文

==线程切换需要2.3步==

**协程**：协程是属于线程的 协程程序是在线程里面跑的，因此协程又称微线程和纤程

协程没有线程的上下文切换 协程的调度是由程序员手动切换的 因此又叫做用户空间线程

由于协程是用户调度的 所以不会出现执行一半的代码片段被强制中断 因此无需原子操作锁

![](image\goroutine.png)

Linux 进程、线程、文件描述符的底层原理：https://mp.weixin.qq.com/s/USb5e2Zoc0LRgRShRpTYfg

**进程 VS 线程**

- 进程是资源分配和调度的最小单位，进程拥有完整虚拟地址空间，同一进程的多个线程可以共享同一地址空间
- 线程是CPU调度的最小单元，一个进程包含若干线程
- 线程比进程小，基本上不拥有系统资源，线程的创建和销毁所需要的时间比进程小很多
- 线程之间共享虚拟地址空间，因此，需要考虑同步和互斥问题
- 一个线程意外终止可能会影响整个进程的正常运行，但是一个进程意外终止不会影响其他进程的运行
- 多进程程序安全性高，进程切换开销大（切换不同的地址空间），效率低。线程程序维护成本高，线程切换开销小，效率高。

### 10.高级go面试题（模拟100个ip频繁访问）

- **未修改版本**

~~~go
//场景：在一个高并发的web服务器中，要限制IP的频繁访问。现模拟100个IP同时并发访问服务器，每个IP要重复访问1000次。每个IP三分钟之内只能访问一次。修改以下代码完成该过程，要求能成功输出 success:100

package main
 
import (
	"fmt"
	"time"
)
 
type Ban struct {
	visitIPs map[string]time.Time
}
 
func NewBan() *Ban {
	return &Ban{visitIPs: make(map[string]time.Time)}
}
func (o *Ban) visit(ip string) bool {
	if _, ok := o.visitIPs[ip]; ok {
		return true
	}
	o.visitIPs[ip] = time.Now()
	return false
}
func main() {
	success := 0
	ban := NewBan()
	for i := 0; i < 1000; i++ {
		for j := 0; j < 100; j++ {
			go func() {
				ip := fmt.Sprintf("192.168.1.%d", j)
				if !ban.visit(ip) {
					success++
				}
			}()
		}
 
	}
	fmt.Println("success:", success)

~~~

- **正确答案版本**

~~~go
package main
 
import (
	"fmt"
	"sync"
	"sync/atomic"
	"time"
)
 
type Ban struct {
	visitIPs map[string]struct{}
}
 
func NewBan() *Ban {
	return &Ban{visitIPs: make(map[string]struct{})}
}
 
//判断IP是否存在
func (o *Ban) visit(ip string) bool {
	mapMutex.Lock()
	defer mapMutex.Unlock()
	if _, ok := o.visitIPs[ip]; ok {
		return true
	}
	o.visitIPs[ip] = struct{}{}
	go o.invalidAfter3Min(ip)
	return false
}
 
// 3分钟后ip失效, 从map中移除. 因此ip再次访问时便可正常访问
func (o *Ban) invalidAfter3Min(ip string) {
	time.Sleep(time.Minute * 3)
	mapMutex.Lock()
	visitIPs := o.visitIPs
	delete(visitIPs, ip)
	o.visitIPs = visitIPs
	mapMutex.Unlock()
}

var mapMutex *sync.Mutex // mutex to avoid concurrent map writes
 
func main() {
	mapMutex = new(sync.Mutex)
	var success int64
	ban := NewBan()
	wg := new(sync.WaitGroup)
	for i := 0; i < 1000; i++ {
		for j := 0; j < 100; j++ {
			wg.Add(1)
			ipEnd := j
			go func() {
				defer wg.Done()
				ip := fmt.Sprintf("192.168.1.%d", ipEnd)
				if !ban.visit(ip) {
					atomic.AddInt64(&success, 1)
				}
			}()
		}
	}
	wg.Wait()
	fmt.Println("success:", success)
}
~~~

### 11. go面试问答题

#### 1. new和make的区别

**答：** 1. 两者都用于在堆上分配内存

​		2. new是初始化一个类型 并返回内存地址， 即返回一个类型为T 值为0的地址指针

​	    3. make只适用于三种内建的引用类型：slice、channel、map 并返回初始值

#### 2. 说说go中的for循环

**答**：for循环支持continue和break操作， 并且提供了一个高级break操作，可以选择中断哪一个循环

#### 3.说说go的select机制

**答**：select是监听和channel有关的IO操作，当IO操作发生时，触发相应的动作

~~~go
//基本用法
select {
    case <- chan1:
    //如果chan1成功读到数据， 则进行该case处理语句
    case chan2 <- 1:
    //如果成功向chan2写入数据，则进行该case处理语句
    default:
    //如果上面都没有成功，则进入default处理流程
}
~~~

#### 4.触发 GC 的时机是什么

主要有两种形式

1. **主动触发**：通过调用runtime.GC来触发GC，此调用阻塞式等待当前GC运行完毕
2. **被动触发**：分为两种
   1. 使用系统监控：当超过两分钟没有产生任何GC 则强制触发GC
   2. 使用步调（pacing）算法，其核心思想是控制内存增长的比例



### 12.go面试编程找错题

#### 1. 写出下面的输出

~~~go
package main
import("fmt") 
func main() {
    defer_call()
}
func defer_call() {
    defer func() {
        fmt.Println("打印前")
    }()
    defer func() {
        fmt.Println("打印中")
    }() 
    defer func() {
        fmt.Println("打印后")
    }() 
    panic("触发异常")
}
~~~

**考点**：defer执行顺序

**解答**：defer类似于栈 先进后出 执行顺序为 ：

~~~go
打印后
打印中
打印前
panic: 触发异常
~~~

#### 2. for range 考点

~~~go
//以下代码有啥问题
type student struct {
	Name string
	Age int
}
func pase_student() {
	m := make(map[string] * student)
	stus := [] student {
		{
			Name: "zhou",
			Age: 24,
		},
		{
			Name: "li",
			Age: 23,
		},
		{
			Name: "wang",
			Age: 22,
		},
	}
	for _, stu := range stus {
		m[stu.Name] = &stu
	}
}
~~~

**解答**：使用for range的时候 使用的是值拷贝 所以所有的key都指向最后一个value

~~~go
//正确写法
for i := 0; i < len(stus); i++ {
    m[stus[i].Name] = &stus[i]
}
for k, v := range m {
    println(k, "=>", v.Name)
}
~~~

~~~go
package main

import (
	"fmt"
)

func main() {
	ch := make(chan *int, 5)
	
    //sender
    input := []int{1,2,3,4,5}
	
    go func(){
		for _, v := range input {
			ch <- &v
		}
		close(ch)
	}()
	//receiver
	for v := range ch {
		fmt.Println(*v)
	}
}
//输出
5
5
5
5
5
~~~

 可以看到5次输出都指向了同一个指针。问题在于这里，在```for range```语句中，`v` 变量用于保存迭代`input`数组所得的值，但是`v`只被声明了一次，此后都是将迭代`input`输出的值赋给`v`， `v`变量的内存地址始终未变，这样再将`v`的地址发送给ch通道， 发送的都是同一个地址。

解决方法：

```go
//引入临时变量
for_, v := range input {
	temp := v
	ch <- &temp
}
//抑或直接饮用数据的内存
for k, _ := range input {
    c <- &input[k]
}
```



#### 3.go的执行随机性和闭包

~~~go
//下面代码会输出什么
func main() {
    runtime.GOMAXPROCS(1)
    wg := sync.WaitGroup {}
    wg.Add(20)
    for i := 0; i < 10; i++ {
        go func() {
            fmt.Println("A: ", i) 
            wg.Done()
        }()
    }
    for i := 0; i < 10; i++ {
        go func(i int) {
            fmt.Println("B: ", i)
            wg.Done()
        }(i)
    }
    wg.Wait()
}
~~~

**答**：随机输出。 但是A输出均为10， B输出为从0到9

#### 4. go的组合继承

~~~go
//下面代码会输出什么
type People struct {}
func(p * People) ShowA() {
    fmt.Println("showA")
    p.ShowB()
}
func(p * People) ShowB() {
    fmt.Println("showB")
}
type Teacher struct {
    People
}
func(t * Teacher) ShowB() {
    fmt.Println("teacher showB")
}
func main() {
    t := Teacher {}
    t.ShowA()
}
~~~

答： 这是Golang的组合模式，可以实现OOP的继承。被组合的类型People所包含的方法虽然升级成了外部类型Teacher这个组合类型的方法（一定要是匿名字段），但它们的方法(ShowA())调用时接受者并没有发生变化。此时People类型并不知道自己会被什么类型组合，当然也就无法调用方法时去使用未知的组合者Teacher类型的功能 

#### 5. SELECT的随机性

~~~go
func main() {
    runtime.GOMAXPROCS(1) 
    int_chan := make(chan int, 1) 
    string_chan := make(chan string, 1) 
    int_chan <- 1 
    string_chan <- "hello"
    select {
        case value := <-int_chan:
            fmt.Println(value)
        case value := <-string_chan:
            panic(value)
    }
}
~~~

**答** ： select会随机选择一个可用的收发操作。所以有可能触发异常也有可能不触发。 单个chan如果无缓冲时，将会阻塞。但结合select可以在多个chan间等待执行，可以有三个基本原则：

1. select中只要有一个case能return，则立即执行
2. 当同一时间有多个case均能return则伪随机方式选取一个执行
3. 如果所有case都不能return 则执行default模块

#### 6. defer执行顺序问题

~~~go
//下面代码输出什么
func calc(index string, a, b int) int {
    ret := a + b 
    fmt.Println(index, a, b, ret) 
    return ret
}
func main() {
    a := 1
    b := 2 
    defer calc("1", a, calc("10", a, b))
    a = 0 
    defer calc("2", a, calc("20", a, b)) 
    b = 1
}
/*
10 1 2 3
20 0 2 2
2 0 2 2
1 1 3 4
*/
~~~

**答**：defer输出时，先将参数存起来 所以此题 应该先输出 calc（“10”，a，b）->calc("20",a,b)->calc("2",a,calc) ->calc("1", a, calc) 

#### 7. map的线程安全问题

~~~go
type UserAges struct {
    ages map[string]
    int sync.Mutex
}
func(ua * UserAges) Add(name string, age int) {
    ua.Lock()
    defer ua.Unlock()
    ua.ages[name] = age
}
func(ua * UserAges) Get(name string) int {
    if age, ok := ua.ages[name]; ok {
        return age
    }
    return -1
}
~~~

可能会出现报错 fatal error : concurrent map read and map write 可以加入读写锁

~~~go
type UserAges struct {
    ages map[string]int 
    sync.RWMutex
}
func(ua * UserAges) Add(name string, age int) {
    ua.Lock()
    defer ua.Unlock()
    ua.ages[name] = age
}
func(ua * UserAges) Get(name string) int {
    ua.RLock()
    defer ua.RUnlock()
    if age, ok := ua.ages[name]; ok {
        return age
    }
    return -1
}
~~~

#### 8.考察接口多态问题

参考文章：https://segmentfault.com/a/1190000022268243

~~~go
//以下编码能编译通过吗？为什么
package main
import (
	"fmt"
)
type People interface {
	Speak(string) string
}
type Stduent struct {}
func(stu * Stduent) Speak(think string)(talk string) {
	if think == "bitch" {
		talk = "You are a good boy"
	} else {
		talk = "hi"
	}
	return
}
func main() {
	var peo People = Stduent{}
	think := "bitch"
	fmt.Println(peo.Speak(think))
}
~~~

**答**： 不能，继承与多态的特点

在golang中对多态的特点体现从语法上并不是很明显

发生多态的几个要素：

1. 有interface接口，并且有接口定义的方法
2. 有子类去重写interface的接口方法
3. 有父类==**指针**==指向子类的具体对象

具体为父类==指针==可以调用子类的具体方法 所以上述代码报错的地方在```var peo people = student{}```这条语句，```student{}```已经重写了父类```People{}```中的Speak方法，那么只需要用父类指针指向子类对象即可。

所以改成```var peo People = &Student{}```即可编译通过

####9.接受者为指针或者值调用方法的区别

~~~go
//当接受者为值时，只能调用值的方法
func main() {
	var a Integer = 1
	var b Integer = 2
	var i interface{} = a
	sum := i.(Integer).Add(b)
	fmt.Println(sum) 
}
type Integer int
func (a Integer)Add(b Integer)Integer{
	return a + b
}
//当接受者为指针时，既可以调用值的方法又可以调用指针的方法
//1
func main() {
	var a Integer = 1
	var b Integer = 2
	var i interface{} = &a
	sum := i.(*Integer).Add(b)
	fmt.Println(sum)
}
type Integer int
func (a *Integer)Add(b Integer)Integer{
	return *a + b
}
//2
func main() {
	var a Integer = 1
	var b Integer = 2
	var i interface{} = &a
	sum := i.(*Integer).Add(b)
	fmt.Println(sum)
}
type Integer int
func (a Integer)Add(b Integer)Integer{
	return a + b
}
~~~

#### 10.defer的有一个特点

~~~go
func main() {
	s := NewSlice()
	defer s.Add(1).Add(2).Add(5).Add(8)
	s.Add(3)
}
type Slice []int
func NewSlice() Slice {
	return make(Slice, 0)
}

func (s *Slice)Add(e int) *Slice {
	*s = append(*s, e)
	fmt.Println(e)
	return s
}
//输出信息
/*
1
2
5
3
8
*/
~~~

### 13.go的垃圾回收

#### 1. 什么是垃圾回收

垃圾回收（garbage collection 缩写为GC），在计算机科学中是一种自动的存储器管理机制。当一个计算机上的动态存储器不再需要时，就应该予以释放，让出存储器，这种存储资源管理成为垃圾回收

简单的说，==垃圾回收是在后台运行的一个守护线程，他的作用是监控各个对象的状态，识别并且丢弃不在使用的对象来释放和重用资源。==

#### 2.go的垃圾回收

当前golang使用的垃圾回收机制是三色标记法配合写屏障和辅助GC，三色标记法是**标记-清除法**的一种增强版本

- 标记-清除法
  1. 标记，先STW（stop the world），暂停整个程序的全部运行线程，将被引用的对象打上标记
  2. 清除没有被打标记的对象，即回收内存资源，然后恢复运行线程

这样做的问题是通过STW保证GC期间标记对象的状态不能变化，整个程序都要暂停掉， 在外部看来程序会卡顿

- 三色标记法

  1. 初始化状态所有对象都是白色

  2. 从root出发扫描所有根对象（图a，b），将他们引用的对象标记位灰色（图A，B）

     （root主要是指程序运行到当前时刻的栈和全局数据区域）

  3. 分析灰色对象是否引用了其他对象，如果没有引用其他对象则将灰色对象标记为黑色；如果有引用则将它变为黑色的同时将他引用的对象标记为灰色

  4. 重复步骤3，直到灰色队列为空，此时，白色对象即为垃圾，进行回收

![](image\interview\gc.png)\

#### 3. 调优

- 避免[]byte 和 string 转化： 两者发生转化的时候，底层数据结构会进行复制，因此导致gc效率会变低
- 少量使用+连接string：go中string是最基础的类型，是一个只读类型，针对他的每一个操作会创建一个新的string。如果少量小文本拼接，用+就好；如果大量小文本拼接 用strings.join； 如果大量大文本拼接，用byte.Buffer

### 14.Golang的语言模型（GPM）

调度本质上体现了对cpu资源的抢占。调度分为：

- 抢占式调度：依赖的是中断机制，通过中断抢回CPU执行权限然后进行调度，如linux内核对线程的调度
- 协作式调度：需要主动让出CPU，调用调度代码进行调度，如协程，没有中断机制一般无法真正做到抢占

**参考文章：**https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/#comments

### 15.go的内存模型

参考文献： https://mp.weixin.qq.com/s/VeNiik-6vi8yQPKnr18w8A

*<u>进程是资源分配的最小单位， 线程是cpu调度的最小单位</u>*

**进程:**

​		在程序启动时，操作系统会给该程序分配一块内存空间，对于程序看到的是一个连续的内存空间，称为**虚拟内存空间**，落实到操作系统内核则是一块一块的内存碎片

![](image\interview\memory1.png)

这片内存又分为用户空间和内核空间，用户空间只用于用户程序的执行，若要执行各种IO操作， 就会通过系统调用进入内核空间操作。

**线程：**

​		线程是进程的一个执行单元， 只有拥有了线程的进程才会被CPU执行，所以一个进程最少拥有一个主线程 。

应用程序的内存载体，我们可以将其简单的分为堆和栈

在go中，栈的内存是由编译器自动分配和释放，栈区往往存储着**函数参数、局部变量和调用函数帧**，他们随着函数的创建而分配，函数的退出而销毁。一个goroutine对应一个栈，栈是调用栈的简称。一个栈通常又包含了许多栈帧（stack frame），它描述的是函数之间的调用关系，每一帧对应一次尚未返回的函数调用，它本身也是以栈形式储存数据。

举例：在一个goroutine里，函数A()正在调用函数B()，那么这个调用栈的内存布局为：

![](image\interview\gostackshiyitu.png)

与栈不同的是，应用程序在运行时只会存在一个堆，程序运行时主动从堆上申请内存，这些内存通过Go的内存分配器分配，并由垃圾回收器回收

栈是每个goroutine独有的，这意味着栈上的内存操作不需要加锁，而堆上的内存有时需要加锁防止多线程冲突。



## ~~8.go需要掌握的知识点（非面试）~~

- ~~go并发模型：通信顺序进程 CSP~~
- ~~进程间通信： 共享内存和通道~~
- ~~检测执行竟态条件： go run -race myapp.go~~
- ~~性能分析器~~
- ~~CGO~~

## 9.常用的算法小技巧

#### 1.循环求余法

![](image\alg\loopcomplementofnumber.png)

#### 2.快速幂方法

参考文章：https://blog.csdn.net/qq_19782019/article/details/85621386

~~~go
//实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题
func myPow(x float64, n int) float64 {
    
    if x == float64(0) {
        return 0
    }
    if n < 0 {
        n = -n
        x = 1 / x
    }
    var res float64 = 1
    for n > 0 {
        if n % 2 == 0 {
            n = n / 2
            x = x * x 
        }else{
            n = n - 1
            res = res * x
            n = n / 2
            x = x * x
        }
    }
    return res
}

//文章中优化后
long long fastPower(long long base, long long power) {
    long long result = 1;
    while (power > 0) {
        if (power % 2 == 1) {
            result = result * base % 1000;
        }
        power = power / 2;
        base = (base * base) % 1000;
    }
    return result;
}
~~~



#### 2.关于linux调优

~~~shell
https://www.cnblogs.com/txlsz/p/13683892.html
~~~

## 10.常见面试题

### 1.输入url发生了什么

1. dns解析
2. 建立tcp连接
3. 发送http请求
4. 关闭tcp连接
5. 浏览器渲染

参考文章：https://mp.weixin.qq.com/s/DLq_GIkdnuOayThfi3jI0A

### 2. 项目中遇到的最大挑战是什么，如何解决的 

谨慎回答

### 3. http2 的特点 

### 4. https加密原理，中间人攻击知道吗 

###5.nginx常用配置

朱双印

###6. CDN 有什么作用 

1. https://developer.aliyun.com/article/577708
2. https://developer.aliyun.com/article/599253
3. https://developer.aliyun.com/article/604600

## 11.腾讯常考面试题

### 1. 算法与数据结构部分

1. 索引B+树
2. ~~redis底层结构~~
3. LRU算法
4. 最大回文串（leetcode第五题）

   

### 2.redis部分

### 3.go部分

1. go的调度
2. go struct能不能比较
3. select作用
4. context包的作用
5. client如何实现长链接
6. 主协程如何等其他协程完在操作
7. slice len cap 共享 扩容
8. map如何顺序读取
9. 实现set
10. 实现消息队列（多生产者 多消费者）
11. 大文件排序
12. 基础排序 哪些是稳定的
13. http get和head
14. http 401 和403
15. http keep-alive
16. http能不能一次连接多次请求 不等后端返回
17. tcp和udp区别 udp有点 适用场景
18. time-wait作用
19. 数据库如何建索引
20. 孤儿进程  僵尸进程
21. 死锁条件 如何避免
22. top 命令 free命令 端口查询netstat 如何发一个信号给一个进程
23. git文件版本 使用顺序 merge和rebase
24. mysql底层有哪几种实现
25. channel底层实现
26. 读写锁底层是怎么实现的
27. 服务发现有哪些机制
28. 当go服务部署上线，发现内存泄漏 该怎么处理

腾讯音乐

1. 二分查找
2. 去重
3. 值溢出（usigned char最大255）
4. 内存对齐
5. 指针强转
6. 排序算法 其时间复杂度 空间复杂度
7. 哈希表原理以及如何解决碰撞
8. golang的slice原理 访问第i个元素的时间复杂度是多少

后端tecent面试

- **golang部分**

1. context作用， 原理， 超时控制
2. 切片和数组区别
3. channel关闭阻塞问题，goroutine如何调度 gopark怎么回事？ PMG模型描述 runtime是怎么个东西 怎么启动第一个goroutine
4. go逃逸分析是怎么回事 内存什么时候栈分配 什么是堆分配
5. sync.Map实现原理 适用的场景
6. go GC算法 三色标记法描述
7. go内存模型（tcmalloc）
8. 100亿个数和100亿个数求交集 时间复杂度
9. 100亿个数求top100 时间复杂度
10.  Select/epoll，IO多路复用，底层数据结构，epoll的几个函数，两种模式 
11.  抢占式调度是什么回事 
12.  用户态和内核态 
13.  hash算法实现(类似crc32或者murmur)，保证随机性和均匀性，减少哈希冲突 
14.  100个球，一次只能拿2-5个，你先拿，我后拿，怎么保证你能拿到最后一个球 
15.  图的最短路径 
16.  正整数数组，求和为sum的组合 换零钱，1,5,10元都很充足，给你N元去换零钱，多少种换法 
17.  遇到过内存溢出吗？怎么解决 

 **主要了解有没有处理过内存泄漏导致的问题，C/C++定位内存泄漏问题；Golang和JAVA主要与GC的工作机制有关，堆内存一直增长，导致应用内存溢出等。** 

18.  服务雪崩怎么处理，怎么解决保证不影响线上 

 **限流，降级，熔断方面措施，结合后端系统架构阐述，如网关的限流和快速失败。** 

19. 

##12.kubernetes面试题

###1.概念问答部分

####1.kubernetes的service概念和它是怎么实现的？

答：当一组pod为其他pod提供服务时，为一组提供同一功能的pod建立一个抽象并追踪这组浮动节点的健康状态，这一抽象就是service

#### 2.执行kubectl exec 背后的原理

kubectl exec 本质是通过docker（或者其他运行时) 的exec来实现。

docker exec的原理： 一个进程可以选择加入到某一个进程已有的Namespace当中，从而达到“进入”这个进程所在容器的目的。

小技巧：查看现有容器的pid ```docker inspect --fromat '{{.State.Pid}}' 4dd5fgghd``` 

当我们执行```docker exec -ti XXX /bin/sh```时。等于是新增一个process（线程）为/bin/sh， 其父进程为docker daemon 新的process加入容器主进程跑p1 所在的namespace

当执行```kubectl exec xxx -- date``` 时， kubectl 向apiserver发起请求， apiserver 转发给pod所在机器的kubelet进程 然后在转发给runtime的exec接口。

参考文章：https://segmentfault.com/a/1190000022163850

### 2.kubernete问题排查部分

#### 1.Pod一直Terminating状态

有可能三种情况：

- ``` Killing container with id docker://apigateway:Need to kill Pod ```

  这种情况可能是磁盘满了

-  ```code = DeadlineExceeded desc = context deadline exceeded```

  这种情况可能是docker17的dockerd的bug 可通过```kubectl delete po name --force --grace-period=0```删除

- 存在finalizers

  通过```kubectl edit```手动编辑资源定义删除finalizers

##13. 学习git/sql/正则的网站

- git

  https://learngitbranching.js.org/

- 正则

   https://regexone.com/ 

   https://regexr.com/ 

- sql

   https://regexr.com/ 





