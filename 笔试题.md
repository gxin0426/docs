### hw

####1. 字符串最后一个单词的长度 

~~~go
package main
import(
    "fmt"
    "strings"
    "bufio"
    "os"
)
func main(){   
        reader := bufio.NewReader(os.Stdin)
        data, _, _ := reader.ReadLine()
        str := string(data)
    a := countLastStr(str)
    fmt.Println(a)
}
func countLastStr(str string) int {
    strs := strings.Fields(str)
    endStr := strs[len(strs) - 1]
    return len(endStr)
}
~~~

####2. 计算字符个数 

~~~go
package main
import (
    "fmt"
    "strings"
)
var(
    inputStr string
    aWord string
)
func main(){   
    fmt.Scanln(&inputStr)
    fmt.Scanln(&aWord)
    inputStr = strings.ToLower(inputStr)
	b := []byte(inputStr)
	b2 := []byte(aWord)
    res := 0
    for i := 0; i < len(b); i ++ {

       if  b[i] == b2[0] {
		res ++
	   }
    }
    fmt.Println(res)     
}
~~~

####3.字符串分割

~~~go
package main
import (
	"fmt"
)
func main(){
	var inputStr1 string
    var inputStr2 string
    _, err := fmt.Scan(&inputStr1)
    if err != nil{
        return
    }
    fmt.Scan(&inputStr2)   
    comF(inputStr1)
    comF(inputStr2)
}
func comF(s string){
    for len(s) > 8 {
        fmt.Println(s[:8])
        s = s[8:]
    }
    arr := make([]byte, 0)
    for j := 0; j < 8 -len(s); j++{
        arr = append(arr, '0')
    }
    s += string(arr)
    fmt.Println(s)
}

//第二种
package main
import "fmt"
func main(){
    
	var num int
	var inputStr string
    for{
    _, err := fmt.Scanln(&num)
    if err != nil {
		return
    }
    for i := 0; i < num; i++{
        fmt.Scanln(&inputStr)
        //fmt.Println(inputStr)
        comF(inputStr)
	}
    }
}
func comF(str string){
    for len(str) > 8 {
        fmt.Println(str[:8])
        str = str[8:]
    }
    
    arr := make([]byte, 0)
    for i := 0; i < 8 -len(str); i++{
        arr = append(arr, '0')
    }
    str += string(arr)
    fmt.Println(str)
}
~~~

####4.进制转换

~~~go
package main
import "fmt"
func main(){
    var n int
    for {      
        _, err := fmt.Scanf("0x%x",&n)
        if err != nil{
            return
        }
        fmt.Println(n)
    }
}
~~~

####5.*质数因子*

~~~go
package main
import (
	"fmt"
)
func main(){
    var i int64
    var n int64
    for{
        _, err := fmt.Scan(&n)
        if err != nil{
            break
        } 
        i = 2
        for n != 1 {
            if n % i == 0{
                fmt.Printf("%d ", i)
                n = n / i
            }else {
                i++
            }
        }
    }
}
~~~

####6.取近似值

~~~go
package main
import (
	"fmt"
	"strconv"
	"strings"
)
func main(){
    var a float64
    for{    
        _, err := fmt.Scan(&a)
        if err !=nil{
            break
        }        
	fmt.Println(commonF(a))
    }
}
func commonF(f float64) int {
	str := strconv.FormatFloat(f, 'G', -1, 32)
	p := strings.Split(str, ".")
	num, _ := strconv.Atoi(p[0])
	num1, _ := strconv.Atoi(p[1])
	if num1 >= 5 {
		num++
		return num
	}else{
		return num
	}	
}
~~~

####7.合并表记录

~~~go
package main
import (
	"fmt"
    "sort"
)
func main(){
    var(
        n int
        k int
        v int
    )
    for {
        _, err := fmt.Scan(&n)
        if err != nil{
            return
        }
        m := make(map[int]int, n)
        
        for i := 0; i < n; i++{
            fmt.Scan(&k, &v)
            
            if m[k] != 0{
                m[k] = m[k] + v
            }else{
                m[k] = v
            }
        }
        keys := make([]int, 0)
        
        for k := range m {
            keys = append(keys, k)
        }
        sort.Ints(keys)
        for _, k := range keys{
            fmt.Println(k, m[k])
        }       
    } 
}
~~~

#### 8. 明明的随机数

~~~go
package main
import (
	"fmt"
	"math/rand"
	"sort"

)
func main(){
	var inputNum int
	a := make([]int, 0)
	fmt.Println("please enter a num")
	fmt.Scanln(&inputNum)
	for i := 0; i < inputNum; i++ {
		a = append(a, rand.Intn(1000))
	}
	fmt.Println(a)
	sort.Ints(a)
	fmt.Println(a)
	//去重
	b := make([]int, 0)
	for i := 0; i < len(a); i++{
		repeat := false
		for j := i + 1; j < len(a); j++{
			if a[i] == a[j]{
				repeat = true
				break
			}
		}
		if !repeat{
			b = append(b, a[i])
		}
	}
	fmt.Println(b)
}
~~~

#### 9. 提取不重复的整数

~~~go
package main
import "fmt"
func main(){
    for {
    var input int
        _, err := fmt.Scan(&input)
        if err != nil{
            return
        }
        m := make(map[int]bool, 0)
        for input > 0 {
            temp := input % 10
            input = input / 10
            if m[temp] == false{
                fmt.Print(temp)
                m[temp] = true
            }
        }
    }
}
~~~

#### 10. 字符个数计算

~~~go
package main
import(
	"fmt"
)
func main(){
	var inputStr string
	fmt.Scan(&inputStr)
    b := []byte(inputStr)
    m := make(map[byte]bool, 0)
    count := 0
    for _, v := range b {
        if _, ok := m[v]; !ok{
            count++
            m[v] = true
        }
    }  
	fmt.Println(count)
}
~~~

#### 11.数字颠倒

~~~go
package main
import(
	"fmt"
)
func main(){
	var input string
    fmt.Scan(&input)
    b := []byte(input)
    var str2 string
    for i := 0; i < len(b); i++{
        str2 += string(b[len(b) - 1 - i])
    }
    fmt.Println(str2)
}
~~~

#### 12.字符串反正

~~~go
package main
import(
	"fmt"
)
func main(){
	var inputStr string
	//fmt.Println("enter a string")
	fmt.Scanln(&inputStr)
	b := []byte(inputStr)
	//fmt.Println(b)
	for i := 0; i < len(b); i++{
		fmt.Print(string(b[len(b) - i -1]))
	}
}
~~~

#### 13.句子逆序

~~~go
package main
import(
	"fmt"
	"strings"
	"os"
	"bufio"
)
func main(){
	//var inputStr string
	//fmt.Println("enter a string")
	reader := bufio.NewReader(os.Stdin)
	data, _, _ := reader.ReadLine()
	//fmt.Println(string(data))
	// fmt.Scan(&inputStr)
	// fmt.Println(inputStr)
	b := strings.Fields(string(data))
	for i := 0; i < len(b); i++{
		fmt.Print(b[len(b) - 1 - i], " ")
	}
}
~~~

#### 14. 字串的连接最长路径查找 

~~~go
package main
import(
    "fmt"
    "sort"
)
func main(){
    var input int
    fmt.Scan(&input)
    var inputStr string
    s := make([]string, 0)
    for i := 0; i < input; i++{
        fmt.Scan(&inputStr)
        s = append(s, inputStr)
    }
    sort.Strings(s)
    for _, v := range s{
        fmt.Println(v)
    }
}
~~~



#### 15. 求int型正整数在内存中存储时1的个数 

~~~go
package main
import(
	"fmt"
)
func main(){
	var inputInt int
	fmt.Scanln(&inputInt)
	count := 0
	for {
		res := 0
		res = inputInt % 2
		inputInt = inputInt / 2
		if res == 1 {
			count++
		}
		if inputInt == 0{
			break
		}
	}
	fmt.Println(count)
}
~~~

#### 16.购物单

#### 17.坐标移动

~~~go
package main
import(
	"fmt"
	"strings"
	_"os"
	_"bufio"
	"strconv"
)
func main(){
	var x int
	var y int
	fmt.Println("enter a string")
	var inputStr string
	fmt.Scanln(&inputStr)
	strSlice := strings.Split(inputStr, ";")
	//fmt.Println(strSlice)
	for i := 0; i < len(strSlice); i++{
		b := []byte(strSlice[i])
		//fmt.Println(b[0])
		var midStr string
		for i := 1; i < len(b); i++{
			midStr = midStr + string(b[i])
		}
		midNum, _ := strconv.Atoi(midStr)
		if string(b[0]) == "A"{
			x = x + midNum
		}else if string(b[0]) == "D"{
			x = x - midNum
		}else if string(b[0]) == "W"{
			y = y + midNum
		} else{
			y = y - midNum
		}
		
	}
	fmt.Println(x,y)
}
~~~

#### 18.最小公倍数

~~~go
package main 
import(
    "fmt"
)
func main(){
    var x int
    var y int
    fmt.Scanf("%d %d", &x, &y)
    fmt.Println(commonF(x,y))
}
func commonF(x, y int) int {
    max := x * y
    i := 0
    if x > y {
        i = x
    }else{
        i = y
    }
    
    for ; x < max; i++{
        if i % x == 0 && i % y == 0{
            return i
        }
    }
    return max
}
~~~

#### 19.最大公约数

~~~go
package main 

import(
    "fmt"
)
func main(){
    var x int
    var y int
	fmt.Scanf("%d %d", &x, &y)
    fmt.Println(commonF(x,y))  
}
func commonF(x, y int) int {
	var n int
    if x < y {
        n = x
    }else{
		n = y
	}
    for i := n ; i >= 1; i-- {
        if x % i == 0 && y % i ==0 {
            return i
        }
    }
    return 1
}
~~~

#### 19-2 求解立方根

~~~go
package main
import(
	"fmt"
	_"io"
	"math"
)
func main(){
	var inputF float64
	fmt.Scan(&inputF)
	x := 1.0
	for {
		if math.Abs(x*x*x - inputF) < 0.0001{
			break
		}
		x = 2*x/3 + inputF/3/x/x
		
	}
	fmt.Printf("%.1f", x)
}
~~~

#### 19-3.记负均正

~~~go
package main
import "fmt"
func main(){
    var input int
    count := 0
    count2 := 0
	sum := 0.0
	for {
	_, err := fmt.Scan(&input)
	if err != nil{
        fmt.Println(count)
		fmt.Printf("%.1f", sum / float64(count2))
		return
	}
    if input < 0 {
        count++
    }else if input > 0{
        count2++
        sum += float64(input)
    }	
}
}
~~~

#### 20.字符逆序

~~~go
package main 
import (
    "fmt"
    "os"
    "bufio"
)
func main(){
    reader := bufio.NewReader(os.Stdin)
    data, _, _ := reader.ReadLine()
    
    for i := 0; i < len(data); i++{
        fmt.Print(string(data[len(data) - 1 - i]))
    }
}
~~~

#### 21.按assii排序输出

~~~go
package main 
import (
    "fmt"
   _ "os"
   _ "bufio"
   _ "strings"
    _"strconv"
    _"encoding/binary"
    "sort"
)
func main(){

    var inputStr string
    fmt.Scanln(&inputStr) 
    b := []byte(inputStr)
//    fmt.Println(b)
    //去重
    midSlice := make([]byte, 0)
	for i := 0; i < len(b); i++{
		repeat := false
		for j := i + 1; j < len(b); j++{
			if b[i] == b[j] {
				repeat = true
				break
		}

    }
    if !repeat {
        midSlice = append(midSlice, b[i])
    }
    }
    midSlice2 := make([]string, len(midSlice))
    for i := 0; i < len(midSlice); i++{
        midSlice2[i] = string(midSlice[i])
    }
    sort.Strings(midSlice2)
    for i := 0; i < len(midSlice2); i++{
        fmt.Print(midSlice2[len(midSlice2) - i - 1])
    }
}
~~~

#### 22. 输入整型数组和排序标识，对其元素按照升序或降序进行排序

~~~go
package main 
import (

    "fmt"
    "sort"
)
func main(){
    var inputInt int
    var jud int
    for{
    _, err := fmt.Scan(&inputInt)
    
    if err != nil{
        break
    }
    var inputIntSlice int
    bSlice := make([]int, inputInt)
    for i := 0; i < inputInt; i++{
        fmt.Scan(&inputIntSlice)
        bSlice[i] = inputIntSlice
    }
    sort.Ints(bSlice)
    
    fmt.Scan(&jud)
    if jud == 0 {
        for i := 0; i < len(bSlice); i++{
            fmt.Printf("%d ", bSlice[i])
        }
    }else {
        for i := 0; i < len(bSlice); i++{
            fmt.Printf("%d ", bSlice[len(bSlice) - 1 - i])
        }
    }
        fmt.Println()
    }
}
~~~

#### 23. 等差数列 

~~~go
package main 
import (
    "fmt"
)
func main(){   
    var inputInt int
    for{
        _, err := fmt.Scan(&inputInt)
        if err != nil {
            break
        }
    b := make([]int64, inputInt)
    for i := 0; i < inputInt; i++{
        if i == 0{
            b[0] = 2
        } else{
            b[i] = b[i - 1] + int64(3)
        }
    }
    var sum int64
    sum = 0
    for i := 0; i < len(b); i++{
        sum = sum + b[i]
    }
    fmt.Println(sum)
    }
}
~~~

#### 24.自守数

~~~go
package main
import (
    "fmt"
)
func main(){
   var input int
    for {
        _, err := fmt.Scan(&input)
        if err != nil {
            break
		}
		count := 1
        for i := 1; i <= input; i++{
            count += comf(i)
		}
		fmt.Println(count)
    } 
}  
func comf(a int) int { 
    i := 10 
    top := a * a 
        for a / i > 0 { 
            i *= 10 
        }
    if a == top % i { 
        return 1 
    }
        return 0
}
~~~

#### 25. 自动售货系统

#### 26.记负均正

~~~go
package main 
import (
    "fmt"
)
func main(){
    var n int
    var num int
    for {
        _, err := fmt.Scan(&n)
        if err != nil{
            break
        }
        sum := 0.0
        count := 0
        count1 := 0
        for i := 0; i < n; i++{
            fmt.Scan(&num)
            if num > 0 {
                sum += float64(num)
                 count++ 
            } else if num < 0{
                count1++
            }
		}
            fmt.Printf("%d %.1f", count1, sum / float64(count))
            fmt.Println()
    }
}
~~~

#### 27.表示数字

~~~go
package main 
import (
    "fmt"
    "strings"
)
func main(){
  var inputStr string
    for{
        _, err := fmt.Scan(&inputStr)
        if err != nil{
            break
        }
  s := []byte(inputStr)
  var str string
  for i := 0; i < len(s); i++ {
    if s[i] >= '0' && s[i] <= '9' {           
       
        str =  str + "*" + string(s[i]) + "*"
    } else{
        str = str + string(s[i])
    }
}
b := strings.Split(str, "**")
var str2 string
for _, v := range b {
    str2 = str2 + v
}
fmt.Println(str2)
} 
}
~~~

#### 28.人民币转换

~~~go
package main 
import (

    "fmt"
    _"os"
    _"bufio"
    _"strings"
    "strconv"
    _"encoding/binary"
    _"sort"
    "regexp"
    "log"

)
func main(){

    var inputFlo float64
    fmt.Scanln(&inputFlo)
    
    str := "人民币" + ConvertNumToCny(inputFlo) 
    fmt.Println(str)

 
} 

func ConvertNumToCny(num float64) string {
    strnum := strconv.FormatFloat(num*100, 'f', 0, 64)
    sliceUnit := []string{"仟", "佰", "拾", "亿", "仟", "佰", "拾", "万", "仟", "佰", "拾", "元", "角", "分"}
    // log.Println(sliceUnit[:len(sliceUnit)-2])
    s := sliceUnit[len(sliceUnit)-len(strnum) : len(sliceUnit)]
    upperDigitUnit := map[string]string{"0": "零", "1": "壹", "2": "贰", "3": "叁", "4": "肆", "5": "伍", "6": "陆", "7": "柒", "8": "捌", "9": "玖"}
    str := ""
    for k, v := range strnum[:] {
        str = str + upperDigitUnit[string(v)] + s[k]
    }
    reg, err := regexp.Compile(`零角零分$`)
    str = reg.ReplaceAllString(str, "整")

    reg, err = regexp.Compile(`零角`)
    str = reg.ReplaceAllString(str, "零")

    reg, err = regexp.Compile(`零分$`)
    str = reg.ReplaceAllString(str, "整")

    reg, err = regexp.Compile(`零[仟佰拾]`)
    str = reg.ReplaceAllString(str, "零")

    reg, err = regexp.Compile(`零{2,}`)
    str = reg.ReplaceAllString(str, "零")

    reg, err = regexp.Compile(`零亿`)
    str = reg.ReplaceAllString(str, "亿")

    reg, err = regexp.Compile(`零万`)
    str = reg.ReplaceAllString(str, "万")

    reg, err = regexp.Compile(`零*元`)
    str = reg.ReplaceAllString(str, "元")

    reg, err = regexp.Compile(`亿零{0, 3}万`)
    str = reg.ReplaceAllString(str, "^元")

    reg, err = regexp.Compile(`零元`)
    str = reg.ReplaceAllString(str, "零")
    if err != nil {
        log.Fatal(err)
    }
    return str
}
~~~

#### 29.计票统计

~~~go
package main
import (
    "fmt"
)
func main() {
	var (
		n int 
		m int 
		str string
	)
	for {
		_, err := fmt.Scan(&n)
		if err != nil{
			break
		}
		s1 := make([]string, 0)
		s2 := make(map[string]int)
		
		for i := 0; i < n; i++{
			fmt.Scan(&str)
			s1 = append(s1, str)
			s2[str] = 0
		}
		inv := 0
		fmt.Scan(&m)
		for j := 0; j < m; j++{
			fmt.Scan(&str)

			if _, ok := s2[str]; ok {
				s2[str]++
			}else{
				inv++
			}
		}
		for _, v := range s1{
			fmt.Printf("%s : %d\n", v, s2[v])
		}
		fmt.Printf("Invalid : %d", inv)
        fmt.Println()
	}
}
~~~

#### 30.  

~~~go

~~~



#### 31. 在字符串中找出连续最长的数字串 

~~~go
package main
import (
	"fmt"
	"regexp"
	"strconv"
)
func main() {
    var inputStr string
    fmt.Scanln(&inputStr)
    pat := "[0-9]+"
    re, _ := regexp.Compile(pat)
    s := re.FindAllString(inputStr, -1)
    //fmt.Println(s)

    midNum := make([]int, len(s))
    for i :=0; i < len(s); i++{
        midNum[i] = commonF(s[i])
    }    
    maxVal := maxF(midNum)
    for i := 0; i < len(midNum); i++{
    
        if midNum[i] == maxVal {
            fmt.Println(s[i])
        }
    }
     fmt.Println(maxVal)
}
func maxF(a []int) int{

    maxValue := 0
    for i := 0; i < len(a); i++{
        if maxValue < a[i] {
            maxValue = a[i]
        }
    }
    return maxValue
}
func commonF(s string) int{
    i, _ := strconv.Atoi(s) 
    count := 1
        if i < 10 { 
            count = 1 
        }else{
            for{
                count++  
                i  = i / 10       
                if i < 10 {  
                    break
            }     
            }
        }    
    return count 
}
~~~

#### 32. 计算n x m的棋盘格子（n为横向的格子数，m为竖向的格子数）沿着各自边缘线从左上角走到右下角，总共有多少种走法 

~~~go
package main
import (
	"fmt"
)
func main() {
    var inputInt1 int
    var inputInt2 int
    for{
    _, err := fmt.Scan(&inputInt1)
    if err != nil{
        break
    }
    fmt.Scan(&inputInt2)
    fmt.Println(commonF(inputInt1, inputInt2))
    }
}
func commonF(a, b int) int{
    if a > 1 && b > 1{
        return commonF(a - 1, b) + commonF(a, b - 1)
    } else if (a >= 1 && b ==1) || (a == 1 && b >= 1){
        return a + b
    } else{
        return 0 
    }
}
~~~

#### 33.合法ip

~~~go
package main
import (
	"fmt"
	"regexp"
	_"strconv"
)
func main() {
    var inputStr string
    for{
        _, err := fmt.Scanln(&inputStr)
        if  err != nil{
            break
        }
    pat := "[0-9]+.[0-9]+.[0-9]+.[0-9]+"
    re, _ := regexp.Compile(pat)
    s := re.MatchString(inputStr)
    if s {
        fmt.Println("YES")
    }else{
        fmt.Println("NO")
    }
    }
}
~~~

#### 34.ASCII表

![](image\ASCII表.jpg)

#### 35.求最大连续bit数

~~~go
package main
import "fmt"
func main(){
    var n int
    for{
        _, err := fmt.Scan(&n)
        if err != nil{
            break
        }        
        fmt.Println(comf(n))
    }
}
func comf( a int) int {
    var t []int
    for a > 0 {
        tem := a % 2
        t = append(t, tem)
        a = a / 2
    }
	//fmt.Println(t)
	max := 0
	count := 0
	for i := 0; i < len(t); i++ {
		if t[i] == 1{
			count++
			if count > max {
				max = count
				
			}
		}else{
		count = 0
	}
	}
	return max
}
~~~

#### 36. 字符串运用-密码截取 

~~~go

~~~

#### 37.获取字符串大写字母的个数

~~~go
package main
import (
	"fmt"
)
func main() {
    for{
        var str string
        _,err:=fmt.Scan(&str)
        if err!=nil{
            return
        }
        b := []byte(str)
    count := 0
    for i := 0; i < len(b); i++{      
        if b[i] >= 'A' && b[i] <= 'Z'{
            count++
        }
    }
    fmt.Println(count)
    }
}
~~~

#### 38.二维数组

~~~go
package main
import (
	"fmt"
)
func main() {
   var (
       row int
       col int

       row1 int
       col1 int 

       row2 int
       col2 int 
    
       irow int
       icol int

       grow int
       gcol int

   )
   for{
        _, err := fmt.Scan(&row)

        if err != nil {
            break
        }
        
        fmt.Scan(&col)
        fmt.Scan(&row1)
        fmt.Scan(&col1)
        fmt.Scan(&row2)
        fmt.Scan(&col2)
        fmt.Scan(&irow)
        fmt.Scan(&icol)
        fmt.Scan(&grow)
        fmt.Scan(&gcol)

        res := make([]int, 5)

        if row <= 0 || col <= 0{
            res[0] = -1
        }
        if row1 < 0 || row1 >= row || col1 < 0 || col1 >= col || row2 < 0 || row2 >= row || col2 < 0 || col2 >= col{
            res[1] = -1
        }

        if irow < 0 || irow >= row{
            res[2] = -1
        }

        if icol < 0 || icol >= col {
            res[3] = -1
        }

        if grow < 0 || grow >= row || gcol < 0 || gcol >= col{
            res[4] = -1
        }

        for _, v := range res{
            fmt.Println(v)
        }
   }


}
~~~

#### 39.真分数分解为埃及分数

~~~go
package main
import (
	"fmt"
	_"regexp"
    "strconv"
    "strings"
)
func main() {

    for {

        var inputStr string
        _, err := fmt.Scan(&inputStr)
        if err != nil{
             break
        }
        var s []string
        s = strings.Split(inputStr, "/")

        num1, err := strconv.Atoi(s[0])
        if err != nil {
            //fmt.Println(err)
            return
        }
        num2, err1 := strconv.Atoi(s[1])
        if err1 != nil{
            //fmt.Println(err1)
            return
        }
        str := ""
        for{

            if num2 % (num1 - 1) == 0 {
                str = str + "1/" + strconv.Itoa(num2 / (num1 - 1)) + "+"
                num1 = 1
            }else{
                midNum := num2 /num1
                midNum2 := num2 - num1 * midNum
                str = str + "1/" + strconv.Itoa(midNum + 1) + "+"
                num1 = num1 - midNum2
                num2 = num2 * (midNum + 1)
                if num2 % num1 == 0{
                    num2 = num2 / num1
                    num1 = 1
                } 
            }
            if num1 == 1{
                break
            }
        }
        str = str + "1/" + strconv.Itoa(num2)
        fmt.Println(str)
    }
}
~~~

#### 40.字符串匹配

~~~go
package main

import(
    "fmt"
    "strings"
)
func main(){
    
    for{
    var strS, strL string
        
        
        _, err := fmt.Scan(&strS)
    if err != nil{
        //fmt.Println(err)
        return
    }
    fmt.Scan(&strL)
            var flag bool
        for _, v := range strS{
            if strings.IndexRune(strL, v) == -1{
                flag = true
                break
            }
        }
        
        fmt.Println(!flag)
    }
}
~~~

#### 41.数组排序

~~~go
package main
import (
	"fmt"
	_"regexp"
    _"strconv"
    _"strings"
    "sort"
)
func main() {
        for{
            var inputNum int
          _, err :=  fmt.Scan(&inputNum)
          if err !=nil {
              return
          }
            num1Slice := make([]int, 0)
        var num1 int
        for i := 0; i < inputNum; i++{
            fmt.Scan(&num1)
            num1Slice = append(num1Slice, num1)
        }
        var inputNum2 int
        _, err2 := fmt.Scan(&inputNum2)
        if err2 != nil{
            return
        }
        num2Slice := make([]int, 0)
        var num2 int
        for i := 0; i < inputNum2; i++{
            fmt.Scan(&num2)
            num2Slice = append(num2Slice, num2)
        }
        num3Slice := append(num1Slice, num2Slice...)               
        // fmt.Println(num3Slice)
        s2 := commonF(num3Slice)
        sort.Ints(s2)
        for _, v := range s2{
            fmt.Printf("%d", v)
            
        }
   fmt.Println()
        }
}
func commonF(s []int) []int{

    newS := make([]int, 0)
    for i := 0; i < len(s); i++{
        repeat := false
        for j := i + 1; j < len(s); j++{ 
            if s[i] == s[j]{ 
                repeat = true 
                break  
            } 
        }
        if !repeat {
            newS = append(newS, s[i])
        }
    }
    return newS
}
~~~

#### 42.字符串的相似度

~~~go

~~~

#### 43.尼科彻斯定理

~~~go
package main

import(
    "fmt"
    "strconv"
)
func main(){   
    for{
        var inputInt int
        _, err := fmt.Scan(&inputInt)
        if err != nil{
            return
        }        
        fmt.Println(comF(inputInt))
    }
}
func comF(a int) string{            
    b := make([]int, a)
    b[0] = a * a - a + 1
    str := strconv.Itoa(b[0])
    
    for i := 1; i < a; i++{
       b[i] = b[i - 1] + 2 
        str = str + "+" + strconv.Itoa(b[i])   
    }   
    return str   
}
~~~

#### 44.参数解析

~~~go
package main

import(
    "fmt"
	"strings"
	"bufio"
	"os"
)
func main(){
	reader := bufio.NewReader(os.Stdin)
    for {
		inputStr, err := reader.ReadString('\n')
        if err != nil {
            // fmt.Println("err: ", err)
            break
        }      
        s := strings.Fields(inputStr)
		fmt.Println(len(s))

		//fmt.Println(s)		
        for _, v := range s { 
            fmt.Println(v)
        } 
    }
}
~~~

#### 45. 计算日期到天数转换 

~~~go
package main

import(
    "fmt"
	_"strings"
	_"bufio"
    _"os"
    _"strconv"
)
func main(){
    
    m := [...]int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}


    var (
        year int
        mon int
        day int
    )
    for{
    _, err := fmt.Scan(&year)
    if err != nil{
        return
    }
    fmt.Scan(&mon)
    fmt.Scan(&day)
    
        if commonF(year){
            m[1] = 29
        }else{
            m[1] = 28
        }

        days := 0

        for i := 0; i < mon - 1; i++{
            day += m[i]
        }

        fmt.Println(days + day)
        //fmt.Println(all) 
}
}
func commonF(a int) bool {
    if (a % 4 == 0 && a % 100 != 0) || a % 400 == 0 {
        return true
    } else{
        return false
    } 

}
~~~

#### 46.买鸡问题

~~~go
package main

import(
    "fmt"
)
func main(){
  
    var m int
    for {
        _, err := fmt.Scan(&m)
        if err != nil{
            break
        }

        for x := 0; x <= 20; x++{
            y := (100 - 7 * x) / 4
            z := 75 + 3 * x /4
            if y > 0 && z > 0 && x + y + z == 100{
                fmt.Println(x, y, z)
            }
        }
    }
}
~~~

#### 47.字符串通配符

~~~go

~~~

#### 48.矩阵估值计算乘的次数

~~~go

~~~

#### 49.成绩排序

~~~go
package main

import(
    "fmt"
	_"strings"
	_"bufio"
    _"os"
    _"strconv"
    "sort"
)
type stu struct {
    name string
    sco int
}

func (s stu) String() string{
    return fmt.Sprintf("%s %d", s.name, s.sco)
}

type sortBySco []stu

func (s sortBySco) Swap(i, j int){
    s[i],s[j]=s[j],s[i]
}

func (s sortBySco) Len()int{
    return len(s)
}

func (s sortBySco) Less(i, j int) bool{
    return s[i].sco < s[j].sco
}
func main(){
    
    
    var n int
    var flag int
    
    for{
        
        _, err := fmt.Scan(&n)
        if err != nil{
            break
        }
        
        fmt.Scan(&flag)
        s := make(sortBySco, n)
        for i := 0; i < n; i++{
            fmt.Scan(&s[i].name, &s[i].sco)
        }
        
        
        if flag == 1 {
            sort.Stable(s)
            
            for k := range s{
                fmt.Printf("%s %d\n", s[k].name, s[k].sco)
            }
        }else if flag == 0 {
            sort.Stable(sort.Reverse(s))
              for k := range s{
                fmt.Printf("%s %d\n", s[k].name, s[k].sco)
            }
        }
    }

}
~~~

#### 50.24点游戏算法

~~~go

~~~

#### 51.配置文件恢复

~~~go

~~~

#### 52.汽水瓶问题

~~~go
package main
import(
    "fmt"
    "io"
)
func main(){
    var n int
    for{
    _, err := fmt.Scan(&n)
    
    if err == io.EOF || n == 0{ 
        break 
    }
        count := 0 
        for n > 2 {
            count += n / 3
            n = n / 3 + n % 3
        }
        if n == 2 {
            count++
        }
        fmt.Println(count)
    }
}
~~~

#### 53.串的模式匹配

~~~go
package main
import(
    "fmt"
    "strings"
)
func main(){
    var str1 string
    var str2 string   
    for{
        _, err := fmt.Scan(&str1)
        if err != nil{
            break
        }
        fmt.Scan(&str2)
        
        if len(str2) < len(str1){
            str1, str2 = str2 , str1
        }	
	outer: for i := len(str1) ; i >= 0; i--{

		for j := 0; j < len(str1); j++{
			if j + i == len(str1) + 1{
				break
			}
			mid := str1[j:j+i]
			if strings.Contains(str2, mid){
				fmt.Println(mid)
				break outer
			}		
		}
	}
}
}
~~~

### LeetCode

#### 1.两个数之和

~~~go
//给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
func twoSum(nums []int, target int) []int {
    var a int
    var b int
    var n []int
    for i := 0; i < len(nums); i++{
        for j := 0; j < len(nums); j++{
            if i == j{
                continue
            } 
            
            if nums[i] + nums[j] == target{
                if i > j {
                   a = j
                   b = i
                  
                }else{
                    a = i
                    b = j
                }
            }
        }
    }
     n = append(n, a)
     n = append(n, b)
     return n
}
~~~

#### 2.整数反转

~~~go
func reverse(x int) int { 
    if x > 0 { 
    var a []int 
    for x > 0 {
        tmp := x % 10
        a = append(a, tmp)
        x = x / 10
        
    }
    //fmt.Println(a)
    mid := 0
    for i := 1; i < len(a) + 1; i++{
        mid = mid + a[len(a) - i] * exp(i)
    }
    return mid
}else{

    x = -x
    var a []int
    for x > 0 {
        tmp := x % 10
        a = append(a, tmp)
        x = x / 10
        
    }
    //fmt.Println(a)
    mid := 0
    for i := 1; i < len(a) + 1; i++{
        mid = mid + a[len(a) - i] * exp(i)
    }
    return -mid
}

}

func exp(a int) int{

    b := 1
    for i := 0; i < a - 1; i++{
        b = b * 10
    }
    return b
}
~~~

#### 3.回文数

~~~go
func isPalindrome(x int) bool {
    if x < 0 {
         return false
    }
    str := strconv.Itoa(x)
    j := len(str) - 1
    for i := 0; i < len(str)/2; i++{
        if str[i] != str[j]{
            return false
        }
        j--
    }
    return true
}
~~~

#### 4.罗马数字转int

~~~go
func romanToInt(s string) int{
    res := 0
    for s != ""{
    if mid1 := strings.Index(s, "CD"); mid1 != -1{
        res += 400
        s = strings.Replace(s, "CD", "", 1)
    }

    if mid2 := strings.Index(s, "CM"); mid2 != -1{
        res += 900
        s = strings.Replace(s, "CM", "", 1)
    }

    if mid3 := strings.Index(s, "XL"); mid3 != -1{
        res += 40
        s = strings.Replace(s, "XL", "", 1)
    }

    if mid4 := strings.Index(s, "XC"); mid4 != -1{
        res += 90
        s = strings.Replace(s, "XC", "", 1)
    }

    if mid5 := strings.Index(s, "IV"); mid5 != -1{
        res += 4
        s = strings.Replace(s, "IV", "", 1)
    }

    if mid6 := strings.Index(s, "IX"); mid6 != -1{
        res += 9
        s = strings.Replace(s, "IX", "", 1)
    }

    for _, v := range s {
        if string(v) == "I"{
            res += 1
            s= strings.Replace(s, "I", "", 1)
        }

        if string(v) == "V"{
            res += 5
            s= strings.Replace(s, "V", "", 1)
        }

        if string(v) == "X"{
            res += 10
            s= strings.Replace(s, "X", "", 1)
        }

        if string(v) == "L"{
            res += 50
            s= strings.Replace(s, "L", "", 1)
        }

        if string(v) == "C"{
            res += 100
            s= strings.Replace(s, "C", "", 1)
        }

        if string(v) == "D"{
            res += 500
            s= strings.Replace(s, "D", "", 1)
        }

        if string(v) == "M"{
            res += 1000
            s= strings.Replace(s, "M", "", 1)
        }
    }
    }
    return res
}
~~~

#### 5.最长公共前缀

~~~go
func longestCommonPrefix(strs []string) string {
    
    if len(strs) == 0{
        return ""
    }
    str := strs[0]
    for i := 1; i < len(strs); i++{
        if strs[i] < str{
            str = strs[i]
        }
    }
    var a []string
    
    outer: for i := 1; i <= len(str); i++{
        
        for j := 0; j < len(strs); j++{
            if strs[0][i - 1:i] != strs[j][i - 1:i]{
                break outer
            }
            
        }
        a = append(a, strs[0][i - 1:i])
    }
    str1 := ""
    for _, v := range a {
        str1 = str1 + v
    }
    return str1   
}
~~~

#### 6.有效的括号

~~~go
func isValid(s string) bool {  
    flag := false
    if len(s) == 0 {
         return true
    }
    m := map[byte]byte{'(':')','{':'}','[':']'}  
    sli := make([]byte, 0) 
    if len(s) % 2 == 1{ 
        return false 
    }
    for i, b := range s { 
        
        if i == 0 && (s[i] == ')' || s[i] == ']' || s[i] == '}'){  
            return false
        }

        if b == '(' || b == '[' || b == '{'{
            sli = append(sli, byte(b)) 
        }else if b ==')' || b == ']' || b == '}'{ 
            left := sli[len(sli) - 1] 
            sli = sli[:len(sli) - 1] 
            if m[left] == byte(b){ 
                flag = true 
            }else{ 
                return false 
            }
        }        
        if i == len(s)-1 && len(sli) != 0 {  
			flag = false 
		} 
    }
    return flag
}
~~~

#### 7.合并两个有序链表

~~~go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
         return l2
    }
    if l2 == nil {
        return l1  
    }
    var res *ListNode
    if l1.Val >= l2.Val{  
        res = l2
        res.Next =  mergeTwoLists(l1, l2.Next)
    }else{
        res = l1
        res.Next = mergeTwoLists(l1.Next, l2)
    }
    return res
}
//方法二
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
        var  data []int
        if l1 == nil{
            return l2
        }
        if l2 == nil{
            return l1
        }
for l1 != nil {
           data = append(data, l1.Val)
           l1 = l1.Next      
    }       
for l2 != nil{
           data = append(data, l2.Val) 
           l2 = l2.Next    
    }    
    sort.Ints(data)
    l3 := &ListNode{data[0], nil}
    l4 := l3
    for i := 1; i < len(data); i++{
        l4.Next = &ListNode{data[i], nil}
        l4 = l4.Next
    return l3
}
~~~

#### 8.删除切片中的重复项

~~~go
func removeDuplicates(nums []int) int {
 
    k := 0
   
    for i := 0; i < len(nums); i++{
        if nums[i] != nums[k]{
            k++
            nums[k] = nums[i]
        }
    }
    return k + 1 
}
~~~

#### 9.移除元素

~~~go
func removeElement(nums []int, val int) int {   
    index := 0
    for ; index < len(nums);{
        if nums[index] == val{
        nums = append(nums[:index],nums[index+1:]...)
        continue
        }
        index++
    }
    return len(nums)
}
~~~

#### 10.实现strStr()

~~~go
func strStr(haystack string, needle string) int {
    return strings.Index(haystack, needle)
}
~~~

#### 11.搜索插入位置

~~~go
func searchInsert(nums []int, target int) int {
    index := 0
    for  i := 0; i < len(nums); i++{
        if nums[i] >= target{
            index = i
            break
    
        }else if nums[i] < target && i == len(nums) - 1{
            index = i + 1
            break
        }
    }
    return index
}
~~~

#### 11.最大子序和

~~~go
func maxSubArray(nums []int) int {
    
    if len(nums) == 0{
         return 0
    }
    if len(nums) == 1{
         return nums[0]
    }
    max := -2147483648
    for i := 0; i < len(nums); i++{
        temp := 0
        max2 := -2147483648
        for j := i; j < len(nums); j++{
            temp += nums[j]
            if max2 < temp {
                    max2 = temp
            }
        }
        if max2 > max {
            max = max2
        }
    }
    return max
}
~~~

#### 12.最后一个单词长度

~~~go
func lengthOfLastWord(s string) int {
   str :=  strings.Fields(s)
   if len(str) == 0 {
        return 0
   }
    return len(str[len(str)-1])
}
~~~

#### 13.加一

~~~go
func plusOne(digits []int) []int {
    digits[len(digits) - 1] += 1

    for i := len(digits) - 1; i >=0; i--{
        if i != 0 && digits[i] > 9 {
            digits[i] = 0
            digits[i - 1] += 1 
        }else if i == 0 && digits[i] > 9{
            digits[i] = 0
            digits = append([]int{1}, digits...)
        }
    }
    return digits
}
~~~

#### 14.求平方

~~~go
//first method
func mySqrt(x int) int {
    b := float64(x)
    c := math.Sqrt(b)
    return int(c)
}

//newton method

~~~

- 牛顿迭代法求方根的迭代公式：X~n+1~ = X~n~ - f(X~n~)/f`(X~n~)

####15.跳楼梯（斐波那契）

~~~go
func climbStairs(n int) int {
    a := []int{1, 2, 3}
    if n < 3 {
        return a[n - 1]
    }
    for i := 3; i < n; i++{
        a = append(a, a[i-1] + a[i-2])
    }
    return a[len(a) - 1]
}
//第二种 性能差
func climbStairs(n int) int {   
    if n ==1 || n == 2{
        return n
    }else {
        return climbStairs(n-1) + climbStairs(n-2)
    }
~~~

#### 16.去除链表中的重复元素

~~~go
//第一种 比较笨
func deleteDuplicates(head *ListNode) *ListNode {
    var mid []int
    if head == nil {
        return nil
    }
    mid = append(mid, head.Val)
    for head.Next != nil{
        head = head.Next
        mid = append(mid, head.Val)
        
    }
    
    b := remove(mid)
    l1 := &ListNode{b[0], nil}

    l2 := l1 
    for i := 1; i < len(b); i++{
        l2.Next = &ListNode{b[i], nil}
        l2 = l2.Next
    }
    return l1
}
func remove(a []int) []int{
    var b []int
    for i := 0; i < len(a); i++{
        repeat := false
       for j := i + 1; j < len(a); j++{
           if a[i] == a[j]{
               repeat = true
               break
           }
       }
       if !repeat {
           b = append(b, a[i])
       }
    }
    return b
}
//第二种 快捷
func deleteDuplicates(head *ListNode) *ListNode {
    if head == nil{
         return nil
    }
    head1 := head
    for head1.Next != nil{
    if head1.Val == head1.Next.Val{
        head1.Next = head1.Next.Next
    }else{
        head1 = head1.Next
    }
    }
    return head
}
~~~

#### 17.合并两个有序数组

~~~go
func merge(nums1 []int, m int, nums2 []int, n int)  {
    for i := 0; i < n; i++{
        nums1[m] = nums2[i]
        m++
    }
    sort.Ints(nums1)
}
~~~

#### 18.相同的树

~~~go
func isSameTree(p *TreeNode, q *TreeNode) bool {
    if p == nil && q == nil{
        return true
    }
    if p == nil || q == nil{
        return false
    }
    if q.Val != p.Val{
        return false
    }
    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)
}
~~~

#### 19.对称二叉树

~~~go
func isSymmetric(root *TreeNode) bool {
    	if root == nil{
		return true
	} else {
		return same(root.Right, root.Left)
	}
}
func same(l *TreeNode, r *TreeNode) bool{
    if l == nil && r == nil {
        return true
    } 
    if l == nil || r == nil{ 
        return false
    }
    if l.Val == r.Val{
        return same(l.Right, r.Left) && same(l.Left, r.Right) 
    }else{
        return false
    }
}
~~~

#### 20. 二叉树最大深度

~~~go
func maxDepth(root *TreeNode) int {  
    if root == nil {    
         return 0    
    }  
    i := 0    
    j := 0    
    i = maxDepth(root.Left) + 1   
    j = maxDepth(root.Right) + 1   
    if j > i {  
         i, j = j, i 
    }
    return i  
}  
~~~

#### 21.将有序数组转换为二叉搜索树

~~~go
func sortedArrayToBST(nums []int) *TreeNode {
    if len(nums) == 0{
         return nil 
    }
    return buildtree(nums, 0, len(nums) - 1) 
}
func buildtree(n []int, i,j int) *TreeNode{
    if i > j {
        return nil
    }
    mid := (i + j) / 2
    n1 := &TreeNode{n[mid], nil, nil}
    n1.Left = buildtree(n, i, mid - 1)
    n1.Right = buildtree(n, mid + 1, j)
    return n1
}
~~~

#### 22.判断平衡二叉树

~~~go
func isBalanced(root *TreeNode) bool {
    if root == nil {
        return true
    }
    i := compare(root.Left)
    j := compare(root.Right)
    
    if math.Abs(float64(j - i)) > 1{
        return false
    }
    if isBalanced(root.Left) == false {
        return false
    }
    if isBalanced(root.Right) == false {
        return false
    }
    return true
}
func compare(root *TreeNode) int{
        if root == nil{
        return 0
    }
    i := 0
    j := 0
    i = compare(root.Left) + 1
    j = compare(root.Right) + 1
        if j > i {  
         i, j = j, i 
    }
    return i
}
~~~

#### 23.最小深度

~~~go
func minDepth(root *TreeNode) int {
   if root == nil {
         return 0
    }   
    i := minDepth(root.Left) + 1
    j := minDepth(root.Right) + 1
	//左子树为0 返回右子树深度+1 右子树为0 返回左子树深度+1
    if i == 1 ||  j == 1{
        return i + j - 1
    }
    if i > j {
        i, j = j, i
    }
    return i
}
~~~

#### 24.路径总和

~~~go
func hasPathSum(root *TreeNode, sum int) bool {
    if root == nil {
         return false
    }
    if root.Left == nil && root.Right == nil {
        return sum - root.Val == 0
    }
    return hasPathSum(root.Left, sum - root.Val) || hasPathSum(root.Right, sum - root.Val)
}
~~~

#### 25.杨辉三角2

~~~go
func getRow(rowIndex int) []int {
    var a [][]int
    a = append(a, []int{1})
        if rowIndex == 0{
         return a[0]
    }
    for i := 1; i <= rowIndex+1; i++{
        temp := make([]int, 0)
        temp = append(temp, 1)
        for j := 1; j < i - 1; j++{
            temp = append(temp, a[i-1][j-1] + a[i-1][j])
        }
        temp = append(temp, 1)
        a = append(a, temp)
    }
    return a[rowIndex+1]
}
~~~

#### 26.卖股票最佳时机

~~~go
func maxProfit(prices []int) int {
    max := -100000
    for i := 0; i < len(prices); i++{
        mid := -10000
        for j := i + 1; j < len(prices); j++{
            temp := prices[j] - prices[i]
            if mid  < temp {
                mid = temp
            }
        }
        if max < mid {
            max = mid
        }
    }
    if max < 0 {
        return 0
    }
    return max 
}
~~~

#### 27.买卖股票最佳时机2

~~~go
func maxProfit(prices []int) int {
    res := 0
    for i := 0; i < len(prices) - 1; i++{
        if prices[i + 1] > prices[i] {
            res += prices[i + 1] - prices[i]
        }   
    }
    return res
}
~~~

#### 28.判断一个字符串是不是回文串

~~~go
func isPalindrome(s string) bool {
    if s == ""{
        return true
    }
    s = strings.ToLower(s)
    var str []string   
    for _, v := range s {
        if (v >= 'a' && v <= 'z') || (v >= '0' && v <= '9') {
            str = append(str, string(v))
        }
    }
    for i := 0; i < len(str)/2; i++{
        if str[i] != str[len(str) - i - 1]{
            return false
        }
    }
    return true
}
~~~

#### 29.只出现一次的数字

~~~go
func singleNumber(nums []int) int {
    index := 0
    for _, v := range nums{
        index ^= v
    }
    return index
}
~~~

#### 30.最小栈

~~~go
type MinStack struct {
    elems []int
    min []int
}
/** initialize your data structure here. */
func Constructor() MinStack {

    return MinStack{make([]int, 0), make([]int, 0)}

}
func (this *MinStack) Push(x int)  {
    this.elems = append(this.elems, x)

    if len(this.min) == 0 || this.GetMin() >= x{
        this.min = append(this.min, x)
    }
}
func (this *MinStack) Pop()  {
    elem := this.Top()

    this.elems = this.elems[:len(this.elems)-1]
 
	if elem <= this.GetMin() {
		this.min = this.min[:len(this.min)-1]
	}
}
func (this *MinStack) Top() int {
    	if len(this.elems) == 0 {
		panic("empty stack")
	}
 
	elem := this.elems[len(this.elems)-1]
	return elem
}
func (this *MinStack) GetMin() int {
    	if len(this.min) == 0 {
		panic("empty stack")
	}
	elem := this.min[len(this.min)-1]
	return elem
}
~~~

#### 31.相交链表

~~~go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    a, b := headA, headB
    for a != b{
        if a == nil{
            a = headB
        }else{
            a = a.Next
        }
        if b == nil{
            b =headA
        }else{
            b = b.Next
        }
    }
    return a
}
~~~

#### 32.两数之和2

~~~go
func twoSum(numbers []int, target int) []int { 
    var a []int
    outer:for i := 0; i < len(numbers) - 1; i++{
            for j := i + 1; j < len(numbers); j++{
                if numbers[i] + numbers[j] == target{
                    a = append(a, i+1)
                    a = append(a, j+1)
                    break outer
                }
            }
    }
    return a 
}
//方法二
//一个双向同时遍历的方法
    for i,j := 0, 10; i < j;{
        j--
        i++
        fmt.Print(" i = ", i)
        fmt.Println()
        fmt.Print(" j = ", j)
    }
//好一点方法
func twoSum(numbers []int, target int) []int {
	for i, j := 0, len(numbers)-1; i < j; {
		if numbers[i]+numbers[j] > target {
			j--
		} else if numbers[i]+numbers[j] < target {
			i++
		} else {
			return []int{i+1, j+1}
		}
	}
	return []int{}
}
~~~

#### 33. Excel表列名称

~~~go

~~~

#### 34.多数元素

~~~go
func majorityElement(nums []int) int {
    if len(nums) == 1{
        return nums[0]
    }
    flag := len(nums)/2 + 1
    res := -1
   outer: for i := 0; i <len(nums); i++{
        count := 1
        for j := i + 1; j < len(nums); j++{
            if nums[i] == nums[j]{
                count++
            }
            if flag <= count {
             res = nums[i]   
             break outer
            } 
        }
    }
    return res
}

//2
func majorityElement(nums []int) int {
    sort.Ints(nums)
    return nums[len(nums)/2]
}

//3
func majorityElement(nums []int) int {
    max := nums[0]
    maxMap := map[int]int{max: 0}
    for i:=0; i<len(nums); i++ {
        maxMap[nums[i]]++
        if maxMap[nums[i]] > maxMap[max] {
            max = nums[i]
        }
    }
    return max
}
~~~

#### 35.阶乘后的零

~~~go
func trailingZeroes(n int) int {  
    res := 0
    for n >= 5{
        res += n / 5
        n = n / 5
    }
    return res
}
~~~

#### 36.旋转数组

~~~go
func rotate(nums []int, k int)  {  
     if len(nums) < k {
         k = k % len(nums)
     }
     a := len(nums)
     mid1 := nums[a - k:]
     mid2 := nums[:a-k]
     mid1 = append(mid1, mid2...) 
     nums = append(nums[:0], mid1...)  
}
~~~

#### 37.颠倒二进制位

~~~go
func reverseBits(num uint32) uint32 {
	str := strconv.FormatUint(uint64(num), 2)
	//fmt.Println(str)
	rev := ""
	for i := len(str); i > 0; i-- {
		rev = rev + str[i-1:i]
	}
	if len(rev) < 32 {
		rev = rev + strings.Repeat("0", 32-len(rev))
	}
	//fmt.Println(rev)
	res, _ := strconv.ParseUint(rev, 2, 64)
	return uint32(res)
}

//由于Go对类型的操作十分严谨，uint32必须和同类型的内置uint32类型进行操作。所以count不能简单地声明为int或者其他整型, 因此当count为0的时候需要多插入一个if statement去结束for循环，不然会引起死循环

//位运算 重点要看的

func reverseBits(num uint32) uint32 {
    bits, count := uint32(0), uint32(31)
    
    for count >= 0 {
        bits |= (num & 1) << count
        num >>= 1
        if (count == 0) {
            return bits
        }
        count--
    }
    return bits
}
~~~

#### 38.有效的电话号码

~~~shell
egrep '^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$' file.txt
~~~

#### 39.打家劫舍

~~~go
//没学会 重点要看
func rob(nums []int) int {
	prevMax, curMax := 0, 0
	for _, v := range nums {
		temp := curMax
		if prevMax+v > curMax {
			curMax = prevMax + v
		}
		prevMax = temp
	}
	return curMax
}
~~~

#### 40.快乐数

~~~go
func isHappy(n int) bool {
    //判断一个数是否出现过的方法 
    //创建一个map[int]bool
    //赋值 m[i] = true
    //if _, ok := i; ok {return false} 
    //m[i] = true
	m := make(map[int]bool)
	sum := nex(n)
	m[sum] = true
	for {
		if sum == 1 {
			return true
		}
		sum = nex(sum)
		if _, ok := m[sum]; ok {
			return false
		}
		m[sum] = true
	}

}
func nex(n int) int {
	sum := 0
	s := 0
	for n != 0 {
		s = n % 10
		sum += s * s
		n /= 10
	}
	return sum
}
~~~

#### 41.移除链表元素

~~~go
func removeElements(head *ListNode, val int) *ListNode { 
    if head == nil {
        return nil
    }
    mid := &ListNode{}
    mid.Next = head
    tem := mid
    for tem.Next != nil{
        if tem.Next.Val == val {
             tem.Next = tem.Next.Next
        }else{
        tem = tem.Next 
        }
    }
    return mid.Next
}
~~~

#### 42.找出小于n的所有质数

~~~go
func countPrimes(n int) int {   
    m := make(map[int]bool, n)
    count := 0
    for i := 2; i < n; i++{
        if m[i] {
            continue
        }
        for j := i + i; j < n; j = j + i{
            m[j] = true
        }
        count++
    }
    return count
}
~~~

#### 43.同构字符串

~~~go
func isIsomorphic(s string, t string) bool {
	if s == "" && t == "" {
		return true
	}
	if len(s) != len(t) {
		return false
	}
	s1 := []byte(s)
	t1 := []byte(t)

	for i := 0; i < len(s1); i++ {
		if bytes.IndexByte(s1, s1[i]) != bytes.IndexByte(t1, t1[i]) {
			return false
			break
		}
	}
	return true
}
~~~



