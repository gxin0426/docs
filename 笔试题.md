### hw

####1. 字符串最后一个单词的长度 

~~~go
package main
import(
    "fmt"
    "strings"
)
func main(){
    
    str := "helo go"
    a := countLastStr(str)
    fmt.Println(a)
}
func countLastStr(str string) int {
 
    if len(strings.Trim(str," ")) == 0{
        return 0
    }
    strs := strings.Fields(str)
    endStr := strs[len(strs) - 1]
    return len(endStr)
   
}
~~~

####2. 计算字符个数 

~~~go
package main
import "fmt"
var(
    inputStr string
    aWord string
)
func main(){

    fmt.Println("Please enter your str")
    fmt.Scanln(&inputStr)
    fmt.Println("Please enter a alp")
    fmt.Scanln(&aWord)
	b := []byte(inputStr)
	b2 := []byte(aWord)
	// fmt.Println(inputStr)
	// fmt.Println(aWord)
	// fmt.Println(b)
	// fmt.Println([]byte(aWord))
    res := 0
    for i := 0; i < len(b); i ++ {
       if  b[i] == b2[0] {
		res ++
	   }
    }
    fmt.Println(res)     
}
~~~

####3.字符串分割

~~~go
package main
import (
	"fmt"
)
func main(){
	var inputStr string
	fmt.Println("please enter a string")
	fmt.Scanln(&inputStr)
	b := []byte(inputStr)
	if len(b) < 8 {
		var str string
		
		for i := 0; i < 8-len(b); i++{
			str = str +"0"
		}
		//fmt.Println(str)
		fmt.Println(string(b) + str )
	}
	rem := len(b) % 8
	if rem == 0{
		for i := 0; i < len(b); i++{
			if i % 8 == 0{
				fmt.Println()
			}	
			fmt.Print(string(b[i]))
		}
	} else{
		var str2 string
		for i := 0; i < 8 - rem; i++{
			str2 = str2 +"0"
		}
		for i := 0; i < len(b); i++{
			if i % 8 == 0{
				fmt.Println()
			}	
			fmt.Print(string(b[i]))	
		}
		fmt.Print(str2)
	}	
}

~~~

####4.进制转换

~~~go
package main
import (
	"fmt"
)
func main(){
	var aNum int
	fmt.Println("enter a num")
	fmt.Scanf("%x", &aNum)
	fmt.Println(aNum)
}
~~~

####5.*质数因子*

~~~go
package main
import (
	"fmt"
)
func main(){
	printPrime(5)
}
func printPrime(n int){
	fmt.Println(n)
	for j := 2; j < n; j++{
		if isPrime(n){
			fmt.Println(n, "素数")
		}
		if n % j == 0 && isPrime(j){
			fmt.Println(j)
		}
	}
}
func isPrime(i int) bool{
	count := 0
	for j := 2; j < i; j++{
		if i % j == 0{
			count++
		}
	}
	if count == 0 {
		return true
	}
	return false
}
~~~

####6.取近似值

~~~go
package main
import (
	"fmt"
	"strconv"
	"strings"
)
func main(){
	var a float64
    fmt.Scanln(&a)
	fmt.Println(commonF(a))
}
func commonF(f float64) int {
	str := strconv.FormatFloat(f, 'G', -1, 32)
	p := strings.Split(str, ".")
	num, _ := strconv.Atoi(p[0])
	num1, _ := strconv.Atoi(p[1])
	if num1 >= 5 {
		num++
		return num
	}else{
		return num
	}	
}
~~~

####7.合并表记录

~~~go
package main
import (
	"fmt"

)
func main(){
var key1, value1 int
m := make(map[int]int, 0)
m[0] = 0
for{
	fmt.Println("enter a key")
	fmt.Scanln(&key1)
	fmt.Println("enter a value")
	fmt.Scanln(&value1)

	for i := 0; i < len(m); i++{
		if i == key1 {
			m[i] = m[i] + value1
		}else{
			m[key1] = value1
		}

	}
	fmt.Println()
	for k, v := range m {
		fmt.Printf("%d : %d", k, v)
		fmt.Println()
	}
}	
}
~~~

#### 8. 明明的随机数

~~~go
package main
import (
	"fmt"
	"math/rand"
	"sort"

)
func main(){
	var inputNum int
	a := make([]int, 0)
	fmt.Println("please enter a num")
	fmt.Scanln(&inputNum)
	for i := 0; i < inputNum; i++ {
		a = append(a, rand.Intn(1000))
	}
	fmt.Println(a)
	sort.Ints(a)
	fmt.Println(a)
	//去重
	b := make([]int, 0)
	for i := 0; i < len(a); i++{
		repeat := false
		for j := i + 1; j < len(a); j++{
			if a[i] == a[j]{
				repeat = true
				break
			}
		}
		if !repeat{
			b = append(b, a[i])
		}
	}
	fmt.Println(b)
}
~~~

#### 9. 提取不重复的整数

~~~go
package main
import (
	"fmt"
)
func main(){
	a := 45667997777
	commonF(a)
}

//取一个多位整数的位数个数
func commonF(num int) {
//	fmt.Println(num,"rrfggffdfd")
	num2 := num	
	res := 0
	for{
		num2 = num2/10
		res++
		if num2 < 10 {
			break
		}
	}

	//取出各位数值并放入slice
	var a = make([]int, res + 1)
	//fmt.Println(res + 1)
	for i := 0; i < res + 1 ; i++{
		a[i] = num%10
		//fmt.Println(c," yyyp")
		fmt.Println(a[i])
		 num = num/10
		// fmt.Println(num/10)	
	}	
	//fmt.Println(a)
	//去重
	midSlice := make([]int, 0)
	for i := 0; i < res + 1; i++{
		repeat := false
		for j := i + 1; j < res + 1; j++{
			if a[i] == a[j] {
				repeat = true
				break
		}
		if !repeat {
			midSlice = append(midSlice, a[i])
		}
	}
	fmt.Println(midSlice)
	//倒叙
	midNum := 0
	for i := 0; i < len(midSlice); i++{
		midNum = midNum + midSlice[i]*(expF(10,len(midSlice) - 1 - i))
	}
	fmt.Println(midNum)
}

//指数函数
func expF(b int,e int) int{
	resu := 1
	for i := 1; i < e + 1; i++{
		resu = resu * b
	} 
	return resu
}
~~~

#### 10. 字符个数计算

~~~go
package main
import(
	"fmt"
)
func main(){
	var inputStr string
	fmt.Println("enter a string")
	fmt.Scanln(&inputStr)

	l1 := len([]rune(inputStr))
	fmt.Println(l1)
}
~~~

#### 11.数字颠倒

~~~go
package main
import(
	"fmt"
	"strconv"
)
func main(){
	var inputInt int
	fmt.Println("enter an int")
	fmt.Scanln(&inputInt)
	//fmt.Println(commonF(inputInt))
	res := commonF(inputInt)

	//将个位数存入数组
	midSlice := make([]int, res)
	for i := 0; i < res; i++{
		midSlice[i] = inputInt % 10
		inputInt = inputInt / 10
	}

	//fmt.Println(midSlice)
	for i := 0; i < len(midSlice); i++{
		fmt.Print(strconv.Itoa(midSlice[i]))	
	}
}
//计算输入整数的位数
func commonF(i int) int{
	res := 0
	for {
		i = i/10
		res++
		if i < 10 {
			break
		}
	}
	//fmt.Println(res + 1)
	return res + 1
}
~~~

#### 12.字符串反正

~~~go
package main
import(
	"fmt"
)
func main(){
	var inputStr string
	//fmt.Println("enter a string")
	fmt.Scanln(&inputStr)
	b := []byte(inputStr)
	//fmt.Println(b)
	for i := 0; i < len(b); i++{
		fmt.Print(string(b[len(b) - i -1]))
	}
}
~~~

#### 13.句子逆序

~~~go
package main
import(
	"fmt"
	"strings"
	"os"
	"bufio"
)
func main(){
	//var inputStr string
	//fmt.Println("enter a string")
	reader := bufio.NewReader(os.Stdin)
	data, _, _ := reader.ReadLine()
	//fmt.Println(string(data))
	// fmt.Scan(&inputStr)
	// fmt.Println(inputStr)
	b := strings.Fields(string(data))
	for i := 0; i < len(b); i++{
		fmt.Print(b[len(b) - 1 - i], " ")
	}
}
~~~

#### 14. 字串的连接最长路径查找 

#### 15. 求int型正整数在内存中存储时1的个数 

~~~go
package main
import(
	"fmt"
)
func main(){
	var inputInt int
	fmt.Scanln(&inputInt)
	count := 0
	for {
		res := 0
		res = inputInt % 2
		inputInt = inputInt / 2
		if res == 1 {
			count++
		}
		if inputInt == 0{
			break
		}
	}
	fmt.Println(count)
}
~~~

#### 16.购物单

#### 17.坐标移动

~~~go
package main
import(
	"fmt"
	"strings"
	_"os"
	_"bufio"
	"strconv"
)
func main(){
	var x int
	var y int
	fmt.Println("enter a string")
	var inputStr string
	fmt.Scanln(&inputStr)
	strSlice := strings.Split(inputStr, ";")
	//fmt.Println(strSlice)
	for i := 0; i < len(strSlice); i++{
		b := []byte(strSlice[i])
		//fmt.Println(b[0])
		var midStr string
		for i := 1; i < len(b); i++{
			midStr = midStr + string(b[i])
		}
		midNum, _ := strconv.Atoi(midStr)
		if string(b[0]) == "A"{
			x = x + midNum
		}else if string(b[0]) == "D"{
			x = x - midNum
		}else if string(b[0]) == "W"{
			y = y + midNum
		} else{
			y = y - midNum
		}
		
	}
	fmt.Println(x,y)
}
~~~

#### 18.最小公倍数

~~~go
package main 

import(
    "fmt"
)
func main(){
    var x int
    var y int
    fmt.Scanf("%d %d", &x, &y)
    fmt.Println(commonF(x,y))
    
}
func commonF(x, y int) int {
    
    var top int = x * y
    var i = x
    if x < y {
        i = y
    }
    for ; i <= top; i++{
        if i % x == 0 && i % y ==0 {
            return i
        }
    }
    return top
}
~~~

#### 19.最大公约数

~~~go
package main 

import(
    "fmt"
)
func main(){
    var x int
    var y int
	fmt.Scanf("%d %d", &x, &y)
    fmt.Println(commonF(x,y))  
}
func commonF(x, y int) int {
	var n int
    if x < y {
        n = x
    }else{
		n = y
	}
    for i := n ; i >= 1; i-- {
        if x % i == 0 && y % i ==0 {
            return i
        }
    }
    return 1
}
~~~

#### 20.字符逆序

~~~go
package main 
import (
    "fmt"
    "os"
    "bufio"
)
func main(){
    reader := bufio.NewReader(os.Stdin)
    data, _, _ := reader.ReadLine()
    
    for i := 0; i < len(data); i++{
        fmt.Print(string(data[len(data) - 1 - i]))
    }
}
~~~

#### 21.按assii排序输出

~~~go
package main 
import (
    "fmt"
   _ "os"
   _ "bufio"
   _ "strings"
    _"strconv"
    _"encoding/binary"
    "sort"
)
func main(){

    var inputStr string
    fmt.Scanln(&inputStr) 
    b := []byte(inputStr)
//    fmt.Println(b)
    //去重
    midSlice := make([]byte, 0)
	for i := 0; i < len(b); i++{
		repeat := false
		for j := i + 1; j < len(b); j++{
			if b[i] == b[j] {
				repeat = true
				break
		}

    }
    if !repeat {
        midSlice = append(midSlice, b[i])
    }
    }
    midSlice2 := make([]string, len(midSlice))
    for i := 0; i < len(midSlice); i++{
        midSlice2[i] = string(midSlice[i])
    }
    sort.Strings(midSlice2)
    for i := 0; i < len(midSlice2); i++{
        fmt.Print(midSlice2[len(midSlice2) - i - 1])
    }
}
~~~

#### 22. 输入整型数组和排序标识，对其元素按照升序或降序进行排序

~~~go
package main 
import (

    "fmt"
    _"os"
    _"bufio"
    _"strings"
    _"strconv"
    _"encoding/binary"
    "sort"
)
func main(){
    var inputInt int
    fmt.Scanln(&inputInt)
    var inputIntSlice int
    bSlice := make([]int, inputInt)
    for i := 0; i < inputInt; i++{
        fmt.Scanln(&inputIntSlice)
        bSlice[i] = inputIntSlice
    }
    sort.Ints(bSlice)
    
    //fmt.Println(bSlice)
    var jud int
    fmt.Scanln(&jud)
    if jud == 0 {
        for i := 0; i < len(bSlice); i++{
            fmt.Print(bSlice[i], " ")
        }
    }else {
        for i := 0; i < len(bSlice); i++{
            fmt.Print(bSlice[len(bSlice) - 1 - i], " ")
        }
    }

}
~~~

#### 23. 等差数列 

~~~go
package main 
import (
    "fmt"
)
func main(){   
    var inputInt int
    fmt.Scanln(&inputInt)
    b := make([]int64, inputInt)
    for i := 0; i < inputInt; i++{
        if i == 0{
            b[0] = 2
        } else{
            b[i] = b[i - 1] + int64(3)
        }
    }
    var sum int64
    sum = 0
    for i := 0; i < len(b); i++{
        sum = sum + b[i]
    }
    fmt.Println(sum)
}
~~~

#### 24.自守数

~~~go
package main 
import (

    "fmt"
    _"os"
    _"bufio"
    _"strings"
    _"strconv"
    _"encoding/binary"
    _"sort"
)
func main(){

    fmt.Println("enter an int")
    var inputInt int
    fmt.Scanln(&inputInt)
    count := 0
  for i := 0; i <= inputInt; i++{      
        

        exp := wsF(i)
        // fmt.Println("exp :", exp + 1)
        midNum := i * i
    //    fmt.Println("midNum ", midNum)
        res := midNum % expF(10, exp + 1) 
    //    fmt.Println(expF(10, exp + 1) )
    //    fmt.Println("res", res)
        //fmt.Println(res)
        if i == res {
             fmt.Println(i)
            count++
        }
   }

    fmt.Println(count)

   
} 

func expF(a int, b int) int{

    sum :=  1
    for i := 0; i < b; i++{
        sum = sum * a 
    }

    return sum 
}

func wsF(a int) int{
    exp := 0
    for j := 0; j < a; j++{
       a = a / 10
       exp++
       if a < 10 {
           break
       } 
    }

    return exp
}
~~~

#### 25. 自动售货系统

#### 26.记负均正

~~~go
package main 
import (
    "fmt"
)
func main(){
    var num int
    fmt.Scanln(&num)
    var num2 int
    b := make([]int, num)
    for i := 0; i < num; i++{
        fmt.Scanln(&num2)
        b[i] = num2
    }
    count := 0
    sum := 0
    for i := 0; i < num; i++{
        if b[i] < 0{
            count++
        }else{
            sum = sum + b[i]
        }
    }   
    fmt.Println(count,sum / (num - count))  
} 
~~~

#### 27.表示数字

~~~go
package main 
import (
    "fmt"
    "strings"
)
func main(){
  var inputStr string
  fmt.Scanln(&inputStr)
  s := []byte(inputStr)
  var str string
  for i := 0; i < len(s); i++ {
    if s[i] >= '0' && s[i] <= '9' {           
       
        str =  str + "*" + string(s[i]) + "*"
    } else{
        str = str + string(s[i])
    }
}
  
b := strings.Split(str, "**")
var str2 string
for _, v := range b {
    str2 = str2 + v
}
fmt.Println(str2)
} 
~~~

#### 28.人民币转换

~~~go
package main 
import (

    "fmt"
    _"os"
    _"bufio"
    _"strings"
    "strconv"
    _"encoding/binary"
    _"sort"
    "regexp"
    "log"

)
func main(){

    var inputFlo float64
    fmt.Scanln(&inputFlo)
    
    str := "人民币" + ConvertNumToCny(inputFlo) 
    fmt.Println(str)

 
} 

func ConvertNumToCny(num float64) string {
    strnum := strconv.FormatFloat(num*100, 'f', 0, 64)
    sliceUnit := []string{"仟", "佰", "拾", "亿", "仟", "佰", "拾", "万", "仟", "佰", "拾", "元", "角", "分"}
    // log.Println(sliceUnit[:len(sliceUnit)-2])
    s := sliceUnit[len(sliceUnit)-len(strnum) : len(sliceUnit)]
    upperDigitUnit := map[string]string{"0": "零", "1": "壹", "2": "贰", "3": "叁", "4": "肆", "5": "伍", "6": "陆", "7": "柒", "8": "捌", "9": "玖"}
    str := ""
    for k, v := range strnum[:] {
        str = str + upperDigitUnit[string(v)] + s[k]
    }
    reg, err := regexp.Compile(`零角零分$`)
    str = reg.ReplaceAllString(str, "整")

    reg, err = regexp.Compile(`零角`)
    str = reg.ReplaceAllString(str, "零")

    reg, err = regexp.Compile(`零分$`)
    str = reg.ReplaceAllString(str, "整")

    reg, err = regexp.Compile(`零[仟佰拾]`)
    str = reg.ReplaceAllString(str, "零")

    reg, err = regexp.Compile(`零{2,}`)
    str = reg.ReplaceAllString(str, "零")

    reg, err = regexp.Compile(`零亿`)
    str = reg.ReplaceAllString(str, "亿")

    reg, err = regexp.Compile(`零万`)
    str = reg.ReplaceAllString(str, "万")

    reg, err = regexp.Compile(`零*元`)
    str = reg.ReplaceAllString(str, "元")

    reg, err = regexp.Compile(`亿零{0, 3}万`)
    str = reg.ReplaceAllString(str, "^元")

    reg, err = regexp.Compile(`零元`)
    str = reg.ReplaceAllString(str, "零")
    if err != nil {
        log.Fatal(err)
    }
    return str
}
~~~

#### 29.计票统计

~~~go

~~~

#### 30. 编写一个函数，传入一个int型数组，返回该数组能否分成两组，使得两组中各元素加起来的和相等，并且，所有5的倍数必须在其中一个组中，所有3的倍数在另一个组中（不包括5的倍数），能满足以上条件，返回true；不满足时返回false。 

~~~go

~~~



#### 31. 在字符串中找出连续最长的数字串 

~~~go
package main
import (
	"fmt"
	"regexp"
	"strconv"
)
func main() {
    var inputStr string
    fmt.Scanln(&inputStr)
    pat := "[0-9]+"
    re, _ := regexp.Compile(pat)
    s := re.FindAllString(inputStr, -1)
    //fmt.Println(s)

    midNum := make([]int, len(s))
    for i :=0; i < len(s); i++{
        midNum[i] = commonF(s[i])
    }    
    maxVal := maxF(midNum)
    for i := 0; i < len(midNum); i++{
    
        if midNum[i] == maxVal {
            fmt.Println(s[i])
        }
    }
     fmt.Println(maxVal)
}
func maxF(a []int) int{

    maxValue := 0
    for i := 0; i < len(a); i++{
        if maxValue < a[i] {
            maxValue = a[i]
        }
    }
    return maxValue
}
func commonF(s string) int{
    i, _ := strconv.Atoi(s) 
    count := 1
        if i < 10 { 
            count = 1 
        }else{
            for{
                count++  
                i  = i / 10       
                if i < 10 {  
                    break
            }     
            }
        }    
    return count 
}
~~~

#### 32. 计算n x m的棋盘格子（n为横向的格子数，m为竖向的格子数）沿着各自边缘线从左上角走到右下角，总共有多少种走法 

~~~go
package main
import (
	"fmt"
)
func main() {
    var inputInt1 int
    var inputInt2 int
    fmt.Scanln(&inputInt1)
    fmt.Scanln(&inputInt2)
    fmt.Println(commonF(inputInt1, inputInt2))
}
func commonF(a, b int) int{
    if a > 1 && b > 1{
        return commonF(a - 1, b) + commonF(a, b - 1)
    } else if (a >= 1 && b ==1) || (a == 1 && b >= 1){
        return a + b
    } else{
        return 0 
    }
}
~~~

#### 33.合法ip

~~~go
package main
import (
	"fmt"
	"regexp"
)
func main() { 
    var inputStr string
    fmt.Scanln(&inputStr)
    pat := "[0-9]+.[0-9]+.[0-9]+.[0-9]+"
    re, _ := regexp.Compile(pat)
    s := re.MatchString(inputStr)
    if s {
        fmt.Print("YES")
    }else{
        fmt.Print("NO")
    }
}
~~~

#### 34.ASCII表

![](image\ASCII表.jpg)

#### 35.求最大连续bit数

~~~go
package main
import (
	"fmt"
	_"regexp"
	_"strconv"
)
func main() {
    var inputB byte
    fmt.Scanln(&inputB)
    s := commonF(inputB)
   // fmt.Println(s)
    b := []byte(s)
    count := 0
    max := 0
    for i := 0; i < len(b); i++{
        if b[i] == '1'{
            count++
        } else {
        
            if max > count {
                count = 0
            } else {
                max = count
                count = 0
            }
        }
    }

    fmt.Println(max)
}
func commonF(n byte) string { 
    if n == 0{
        return "0"
    }
    s := ""
    for q := n; q > 0; q = q / 2{
        m := q % 2
        s = fmt.Sprintf("%v%v", m, s)
    }
    return s
}
~~~

#### 36. 字符串运用-密码截取 

~~~go

~~~

#### 37.获取字符串大写字母的个数

~~~go
package main
import (
	"fmt"
)
func main() {
    for{
        var str string
        _,err:=fmt.Scan(&str)
        if err!=nil{
            return
        }
        b := []byte(str)
    count := 0
    for i := 0; i < len(b); i++{      
        if b[i] >= 'A' && b[i] <= 'Z'{
            count++
        }
    }
    fmt.Println(count)
    }
}
~~~

#### 38.二维数组

~~~go
package main
import (
	"fmt"
)
func main() {
   var (
       row int
       col int

       row1 int
       col1 int 

       row2 int
       col2 int 
    
       irow int
       icol int

       grow int
       gcol int

   )
   for{
        _, err := fmt.Scan(&row)

        if err != nil {
            break
        }
        
        fmt.Scan(&col)
        fmt.Scan(&row1)
        fmt.Scan(&col1)
        fmt.Scan(&row2)
        fmt.Scan(&col2)
        fmt.Scan(&irow)
        fmt.Scan(&icol)
        fmt.Scan(&grow)
        fmt.Scan(&gcol)

        res := make([]int, 5)

        if row <= 0 || col <= 0{
            res[0] = -1
        }
        if row1 < 0 || row1 >= row || col1 < 0 || col1 >= col || row2 < 0 || row2 >= row || col2 < 0 || col2 >= col{
            res[1] = -1
        }

        if irow < 0 || irow >= row{
            res[2] = -1
        }

        if icol < 0 || icol >= col {
            res[3] = -1
        }

        if grow < 0 || grow >= row || gcol < 0 || gcol >= col{
            res[4] = -1
        }

        for _, v := range res{
            fmt.Println(v)
        }
   }


}
~~~

#### 39.真分数分解为埃及分数

~~~go
package main
import (
	"fmt"
	_"regexp"
    "strconv"
    "strings"
)
func main() {

    for {

        var inputStr string
        fmt.Scan(&inputStr)

        var s []string
        s = strings.Split(inputStr, "/")

        num1, err := strconv.Atoi(s[0])
        if err != nil {
            fmt.Println(err)
            return
        }
        num2, _ := strconv.Atoi(s[1])

        str := ""
        for{

            if num1 == 1{
                break
            }

            if num2 % (num1 - 1) == 0 {
                str = str + "1/" + strconv.Itoa(num2 / (num1 - 1)) + "+"
                num1 = 1
            }else{
                midNum := num2 /num1
                midNum2 := num2 - num1 * midNum
                str = str + "1/" + strconv.Itoa(midNum + 1) + "+"
                num1 = num1 - midNum2
                num2 = num2 * (midNum + 1)  
                if num2 % num1 == 0{
                    num2 = num2 / num1
                    num1 = 1
                } 
            }
        }
        str = str + "1/" + strconv.Itoa(num2)
        fmt.Println(str)
    }

}
~~~

#### 40.字符串匹配

~~~go
package main

import(
    "fmt"
    "strings"
)
func main(){
    
    for{
    var strS, strL string
        
        
        _, err := fmt.Scan(&strS)
    if err != nil{
        //fmt.Println(err)
        return
    }
    fmt.Scan(&strL)
            var flag bool
        for _, v := range strS{
            if strings.IndexRune(strL, v) == -1{
                flag = true
                break
            }
        }
        
        fmt.Println(!flag)
    }
}
~~~

#### 41.数组排序

~~~go
package main
import (
	"fmt"
	_"regexp"
    _"strconv"
    _"strings"
    "sort"
)
func main() {
        for{
            var inputNum int
          _, err :=  fmt.Scan(&inputNum)
          if err !=nil {
              return
          }
            num1Slice := make([]int, inputNum)
        var num1 int
        for i := 0; i < inputNum; i++{
            fmt.Scan(&num1)
            num1Slice[i] = num1
        }
        var inputNum2 int
        _, err2 := fmt.Scan(&inputNum2)
        if err2 != nil{
            return
        }
        num2Slice := make([]int, inputNum2)
        var num2 int
        for i := 0; i < inputNum2; i++{
            fmt.Scan(&num2)
            num2Slice[i] = num2
        }
        num3Slice := append(num1Slice, num2Slice...)      
        // fmt.Println(num3Slice)
        s2 := commonF(num3Slice)
        sort.Ints(s2)
        for _, v := range s2{
            fmt.Print(v)
        }
        }
}
func commonF(s []int) []int{

    newS := make([]int, 0)
    for i := 0; i < len(s); i++{
        repeat := false
        for j := i + 1; j < len(s); j++{
            if s[i] == s[j]{
                repeat = true
                break
            }
        }

        if !repeat {
            newS = append(newS, s[i])
        }
    }
    return newS
}
~~~

#### 42.字符串的相似度

~~~go

~~~

