### 1. http

http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name

从上面的URL可以看出，一个完整的URL包括以下几部分：

1. 协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符
2. 域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用
3. 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口
4. 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”
5. 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名

6. 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分
7. 参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。

### linux收发包

- 网卡驱动：网卡需要有驱动才能工作，驱动是加载到内核中的模块，负责衔接网卡和内核的网络模块，驱动在加载的时候将自己注册进网络模块，当相应的网卡收到数据包时，网络模块会调用相应的驱动程序处理数据。

```
                   +-----+
                   |     |                            Memroy
+--------+   1     |     |  2  DMA     +--------+--------+--------+--------+
| Packet |-------->| NIC |------------>| Packet | Packet | Packet | ...... |
+--------+         |     |             +--------+--------+--------+--------+
                   |     |<--------+
                   +-----+         |
                      |            +---------------+
                      |                            |
                    3 | Raise IRQ                  | Disable IRQ
                      |                          5 |
                      |                            |
                      ↓                            |
                   +-----+                   +------------+
                   |     |  Run IRQ handler  |            |
                   | CPU |------------------>| NIC Driver |
                   |     |       4           |            |
                   +-----+                   +------------+
                                                   |
                                                6  | Raise soft IRQ
                                                   |
                                                   ↓
```

过程：

1. 数据包从外面的网络进入物理网卡。如果目的地址不是该网卡，且该网卡没有开启混杂模式，该包会被网卡丢弃。
2. 网卡将数据包通过[DMA](https://link.segmentfault.com/?enc=45Y22GjWqnHHVt7N4713Sg%3D%3D.RTcovGyeqreqo7PEKrivSG7rR7vrhmj3zEmILuM1SkkzN8z%2B2%2FFIVNKW1VcLddtI06eQlBNQD5wpNYSTMhncvg%3D%3D)的方式写入到指定的内存地址，该地址由网卡驱动分配并初始化。注： 老的网卡可能不支持DMA，不过新的网卡一般都支持。
3. 网卡通过硬件中断（IRQ）通知CPU，告诉它有数据来了
4. CPU根据中断表，调用已经注册的中断函数，这个中断函数会调到驱动程序（NIC Driver）中相应的函数
5. 驱动先禁用网卡的中断，表示驱动程序已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知CPU了，这样可以提高效率，避免CPU不停的被中断。
6. 启动软中断。这步结束后，硬件中断处理函数就结束返回了。由于硬中断处理程序执行的过程中不能被中断，所以如果它执行时间过长，会导致CPU没法响应其它硬件的中断，于是内核引入软中断，这样可以将硬中断处理函数中耗时的部分移到软中断处理函数里面来慢慢处理。

##### 文章：https://segmentfault.com/a/1190000008836467

##### 文章：https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/

##### 文章：https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/



### k8 网络协议解析

#### 基础知识

##### route

```shell
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.8.1     0.0.0.0         UG    100    0        0 em1
10.244.0.0      10.244.0.0      255.255.255.0   UG    0      0        0 flannel.1
10.244.1.0      0.0.0.0         255.255.255.0   U     0      0        0 cni0
10.244.2.0      10.244.2.0      255.255.255.0   UG    0      0        0 flannel.1
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
192.168.8.0     0.0.0.0         255.255.252.0   U     100    0        0 em1
```

在路由表的输出中，每一行都包含了以下几个字段：

1. **Destination**（目标地址）：表示数据包要到达的目标地址或目标网络的IP地址。这个字段指定了数据包的最终目的地。
2. **Gateway**（网关）：指定了数据包应该经过哪个路由网关来到达目标地址。网关通常是一个路由器或者中间设备，它负责将数据包从本地网络发送到目标网络。
3. **Genmask**（子网掩码）：子网掩码指定了目标地址或目标网络的范围。它用于确定哪些地址属于同一目标网络。通常以CIDR（Classless Inter-Domain Routing）格式表示，例如，255.255.255.0 或 /24。
4. **Flags**（标志）：这是一个描述路由属性的字段，通常包括以下标志：
   - **U**（Up）：表示路由是活动的，可以使用。
   - **G**（Gateway）：表示这是一个网关路由，需要将数据包发送到指定的网关以进行转发。
   - **H**（Host）：表示这是一个主机路由，目标是一个具体的主机而不是一个网络。
   - **D**（Dynamic）：表示路由是动态生成的，通常由路由协议（如BGP、OSPF等）生成。
   - **C**（Cache）：表示路由是从缓存中获取的。
5. **Metric**（跃点）：跃点值用于确定路由的优先级。较低的跃点值通常表示较高的优先级，数据包将选择具有最低跃点值的路由。
6. **Ref**（参考次数）：表示有多少个路由表项引用了这个路由。这对于确定哪些路由是活动的非常有用。
7. **Use**（使用次数）：表示有多少个数据包已经通过这个路由表项进行了路由。
8. **Iface**（接口）：指定了数据包将通过哪个网络接口发送。这是一个与路由表项相关联的网络接口的名称。



```shell
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.244.1.0      0.0.0.0         255.255.255.0   U     0      0        0 cni0
```

- **Destination**（目标地址）：`10.244.1.0` 表示这是一个目标网络的IP地址。这个目标网络的IP地址范围是 `10.244.1.0` 到 `10.244.1.255`，使用了子网掩码 `255.255.255.0`，表示这是一个/24子网。
- **Gateway**（网关）：`0.0.0.0` 表示没有明确的网关，通常表示这个目标网络是本地网络（直连网络）。这意味着数据包将直接发送到目标网络上的主机，而不需要经过中间网关。
- **Genmask**（子网掩码）：`255.255.255.0` 是目标网络的子网掩码，它指定了目标网络的范围。
- **Flags**（标志）：`U` 表示这是一个直连路由（Connected），这意味着数据包将直接发送到目标网络上的主机，而不需要经过网关。
- **Metric**（跃点）：`0` 表示这个路由的跃点值。跃点用于确定路由的优先级，较低的跃点值通常表示较高的优先级。

这一行表示一个直连路由，将数据包发送到目标网络 `10.244.1.0/24`，并且数据包将直接发送到这个网络上的主机，而不需要经过网关。该路由项使用了网络接口 `cni0` 来进行数据包的发送和接收。



```shell
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.8.0     0.0.0.0         255.255.252.0   U     100    0        0 em1
```



这行路由规则表示的是一个在 Linux 系统下配置的静态路由。我们可以逐部分地解释它：

1. **目的网络地址 (192.168.8.0)**: 这是目标网络的 IP 地址。在这个例子中，192.168.8.0 表示一个私有（本地）网络地址。
2. **网关地址 (0.0.0.0)**: 这个字段指示用于到达目的地的网关。0.0.0.0 表示没有特定网关，即直接路由到目的网络。
3. **子网掩码 (255.255.252.0)**: 这是网络掩码，用于确定 IP 地址中哪部分是网络地址，哪部分是主机地址。在这个例子中，255.255.252.0 表示子网掩码，允许网络地址从 192.168.8.0 到 192.168.11.255。

这行路由规则意味着所有发往 192.168.8.0/22（即从 192.168.8.0 到 192.168.11.255）网络的数据包都将直接通过 em1 接口发送，不需要经过任何网关。

```shell
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.244.2.0      10.244.2.0      255.255.255.0   UG    0      0        0 flannel.1
```

1. **目的网络地址 (10.244.2.0)**: 这是目标网络的 IP 地址。10.244.2.0 是一个私有（本地）网络地址。
2. **网关地址 (10.244.2.0)**: 这个字段指示用于到达目的地的网关。这里的网关地址和目的网络地址相同，这在某些特殊配置中是可能的，特别是在虚拟网络或特定类型的 VPN 配置中。
3. **子网掩码 (255.255.255.0)**: 这是网络掩码，用于确定 IP 地址中的网络和主机部分。255.255.255.0 表示子网掩码，允许网络地址为 10.244.2.0 到 10.244.2.255。

这条路由规则表示所有发往 10.244.2.0/24 网络的数据包应该通过虚拟接口 "flannel.1" 传输，并且即使目的地和网关地址相同，也需要通过一个网关来路由这些数据包。这种配置通常见于虚拟化环境或复杂的网络设置中。

##### iptables

###### nat经过的链

![](network/iptables01.png)

###### 概念

规则存储在内核空间的信息 包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等

![](network/iptables02.png)

raw和mangle在k8s网络中很少用到，为了方便记忆，只给出每个链中的常用表

|    chain    |    table    |
| :---------: | :---------: |
| prerouting  |     nat     |
|   forward   |   filter    |
|    input    |   filter    |
|   output    | filter, nat |
| postrouting |     nat     |

###### 命令用法

![](network/iptables03.png)

**查询**

**Command**：这一列展示了`iptables`可用的命令选项，它们用于定义要对规则集（或单个规则）执行的操作：

- `-A`：Append，将规则添加到链的末尾。
- `-D`：Delete，删除一个指定的规则。
- `-I`：Insert，在指定的位置插入一条规则。
- `-R`：Replace，替换一个指定的规则。
- `-L`：List，列出链中的所有规则。
- `-F`：Flush，删除链中的所有规则。
- `-Z`：Zero，将链中所有规则的计数器归零。
- `-N`：New chain，创建一个新的链。
- `-X`：Delete chain，删除一个非内置的链。
- `-P`：Policy，为链设置默认策略。

**Parameter**：参数用于进一步定义规则的匹配条件，可以指定源地址、目的地址、协议类型等：

- `-p`：Protocol，指定匹配的协议，如tcp、udp、icmp等。
- `-s`：Source，指定源IP地址。
- `-d`：Destination，指定目的IP地址。
- `-i`：In-interface，指定进入网络接口。
- `-o`：Out-interface，指定出去的网络接口。
- `--sport`：Source port，指定源端口。
- `--dport`：Destination port，指定目的端口。

**创建**

好的，我会对每个示例进行详细解释，包括每个参数的作用：

匹配模块

1. **`state`**:
   - 示例：`iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT`
   - 解释：
     - `-A INPUT`：在`INPUT`链上追加一条规则。
     - `-m state`：使用`state`模块，它可以根据连接的状态来匹配数据包。
     - `--state ESTABLISHED,RELATED`：只匹配状态为`ESTABLISHED`（已建立的连接）或`RELATED`（与已有连接相关联的数据包）的数据包。
     - `-j ACCEPT`：匹配的数据包将被接受。

2. **`tcp`/`udp`**:
   - 示例：`iptables -A INPUT -p tcp --dport 22 -j ACCEPT`
   - 解释：
     - `-A INPUT`：在`INPUT`链上追加一条规则。
     - `-p tcp`：指定匹配TCP协议。
     - `--dport 22`：匹配目的端口为22的数据包。
     - `-j ACCEPT`：匹配的数据包将被接受。

3. **`icmp`**:
   - 示例：`iptables -A INPUT -p icmp --icmp-type echo-request -j DROP`
   - 解释：
     - `-A INPUT`：在`INPUT`链上追加一条规则。
     - `-p icmp`：指定匹配ICMP协议。
     - `--icmp-type echo-request`：匹配ICMP类型为回显请求（即ping请求）的数据包。
     - `-j DROP`：匹配的数据包将被丢弃。

4. **`owner`**:
   - 示例：`iptables -A OUTPUT -m owner --uid-owner 1000 -j REJECT`
   - 解释：
     - `-A OUTPUT`：在`OUTPUT`链上追加一条规则。
     - `-m owner`：使用`owner`模块，它可以根据数据包的拥有者来匹配数据包。
     - `--uid-owner 1000`：匹配由用户ID为1000的用户生成的数据包。
     - `-j REJECT`：匹配的数据包将被拒绝。

5. **`recent`**:
   - 示例：`iptables -A INPUT -m recent --name portscan --rcheck --seconds 60 -j DROP`
   - 解释：
     - `-A INPUT`：在`INPUT`链上追加一条规则。
     - `-m recent`：使用`recent`模块，它可以用来动态地追踪最近看到的IP地址。
     - `--name portscan`：为这个追踪创建一个名为`portscan`的列表。
     - `--rcheck`：检查源地址是否在`portscan`列表中。
     - `--seconds 60`：如果源地址在过去60秒内已出现在列表中，则匹配。
     - `-j DROP`：匹配的数据包将被丢弃。

6. **`limit`**:
   - 示例：`iptables -A INPUT -p icmp -m limit --limit 1/s -j ACCEPT`
   - 解释：
     - `-A INPUT`：在`INPUT`链上追加一条规则。
     - `-p icmp`：指定匹配ICMP协议。
     - `-m limit`：使用`limit`模块，它可以限制匹配规则的频率。
     - `--limit 1/s`：每秒只匹配一个数据包。
     - `-j ACCEPT`：匹配的数据包将被接受。

7. **`multiport`**:
   - 示例：`iptables -A INPUT -p tcp -m multiport --dports 22,80,443 -j ACCEPT`
   - 解释：
     - `-A INPUT`：在`INPUT`链上追加一条规则。
     - `-p tcp`：指定匹配TCP协议。
     - `-m multiport`：使用`multiport`模块，它可以匹配多个

端口。
     - `--dports 22,80,443`：匹配目的端口为22、80或443的数据包。
     - `-j ACCEPT`：匹配的数据包将被接受。

8. **`comment`**:
   - 示例：`iptables -A INPUT -p tcp --dport 22 -j ACCEPT -m comment --comment "Allow SSH"`
   - 解释：
     - `-A INPUT`：在`INPUT`链上追加一条规则。
     - `-p tcp`：指定匹配TCP协议。
     - `--dport 22`：匹配目的端口为22的数据包。
     - `-j ACCEPT`：匹配的数据包将被接受。
     - `-m comment`：使用`comment`模块，它允许在规则中添加注释。
     - `--comment "Allow SSH"`：为规则添加注释，说明其目的。

9. **`conntrack`**:
   - 示例：`iptables -A FORWARD -m conntrack --ctstate NEW -j ACCEPT`
   - 解释：
     - `-A FORWARD`：在`FORWARD`链上追加一条规则。
     - `-m conntrack`：使用`conntrack`模块，它可以根据连接跟踪信息来匹配数据包。
     - `--ctstate NEW`：匹配新建立的连接的数据包。
     - `-j ACCEPT`：匹配的数据包将被接受。

10. **`string`**:
    - 示例：`iptables -A INPUT -m string --algo bm --string "badcontent" -j DROP`
    - 解释：
      - `-A INPUT`：在`INPUT`链上追加一条规则。
      - `-m string`：使用`string`模块，它可以匹配数据包内容中的特定字符串。
      - `--algo bm`：指定使用Boyer-Moore算法进行字符串匹配。
      - `--string "badcontent"`：匹配包含字符串"badcontent"的数据包。
      - `-j DROP`：匹配的数据包将被丢弃。

目标模块

1. `ACCEPT`:
   - 示例：`iptables -A INPUT -p tcp --dport 80 -j ACCEPT`
   - 解释：
     - `-A INPUT`：在`INPUT`链上追加一条规则。
     - `-p tcp`：指定匹配TCP协议。
     - `--dport 80`：匹配目的端口为80的数据包。
     - `-j ACCEPT`：匹配的数据包将被接受。

2. `DROP`:
   - 示例：`iptables -A INPUT -s 192.168.1.1 -j DROP`
   - 解释：
     - `-A INPUT`：在`INPUT`链上追加一条规则。
     - `-s 192.168.1.1`：匹配来源于特定IP（192.168.1.1）的数据包。
     - `-j DROP`：匹配的数据包将被丢弃。

3. `REJECT`:
   - 示例：`iptables -A INPUT -p tcp --dport 23 -j REJECT`
   - 解释：
     - `-A INPUT`：在`INPUT`链上追加一条规则。
     - `-p tcp`：指定匹配TCP协议。
     - `--dport 23`：匹配目的端口为23的数据包。
     - `-j REJECT`：匹配的数据包将被拒绝，并向发送方发送错误响应。

4. `LOG`:
   - 示例：`iptables -A INPUT -p tcp --dport 80 -j LOG --log-prefix "HTTP traffic: "`
   - 解释：
     - `-A INPUT`：在`INPUT`链上追加一条规则。
     - `-p tcp`：指定匹配TCP协议。
     - `--dport 80`：匹配目的端口为80的数据包。
     - `-j LOG`：记录匹配的数据包信息。
     - `--log-prefix "HTTP traffic: "`：在日志消息前添加前

**删除**

1. 按规则规格删除

如果您知道要删除的规则的完整细节，可以直接指定这些细节来删除规则。这是最精确的方法。

- 示例：`iptables -D INPUT -p icmp --icmp-type echo-request -j DROP`
- 解释：这条命令会删除`INPUT`链中所有精确匹配该规则的实例。

2. 按规则编号删除

每条规则在链中都有一个编号。您可以先列出链中的所有规则，查看每条规则的编号，然后根据编号来删除规则。

- 列出规则及其编号：`iptables -L INPUT --line-numbers`
- 删除特定编号的规则：`iptables -D INPUT [规则编号]`
- 示例：如果要删除的规则是第3条，使用`iptables -D INPUT 3`。

3. 清空整个链

如果您想删除某个链中的所有规则，可以使用`flush`命令来清空整个链。

- 示例：`iptables -F INPUT`
- 解释：这条命令会删除`INPUT`链中的所有规则。

4. 删除自定义链

如果您创建了一个自定义链，并且想要删除它，需要先清空链中的所有规则，然后删除链。

- 清空链中的规则：`iptables -F [自定义链名]`
- 删除链：`iptables -X [自定义链名]`
- 示例：如果链名为`MYCHAIN`，使用`iptables -F MYCHAIN`然后`iptables -X MYCHAIN`。

5. 重置到默认状态

如果您想要重置`iptables`到默认状态，可以使用`flush`命令清空所有内置链，然后重新设置默认策略。

- 清空所有链：`iptables -F`
- 重置默认策略：`iptables -P INPUT ACCEPT; iptables -P FORWARD ACCEPT; iptables -P OUTPUT ACCEPT`

###### k8s中的iptables

集群默认kube-proxy使用iptables和flannel使用的iptables

**几个重要的链**

```bash
Chain KUBE-MARK-MASQ (87 references)
target     prot opt source               destination
MARK       all  --  anywhere             anywhere             MARK or 0x4000

这条 `iptables` 规则位于 `KUBE-MARK-MASQ` 链中，是 Kubernetes 网络策略的一部分，用于实现源地址转换（Source NAT, SNAT）的标记。我们来解释这条规则的具体作用：

- `target`: `MARK` - 这指明了该规则将执行的动作，即修改数据包的标记（mark）。
- `prot opt`: `all` - 这表明规则适用于所有类型的协议。
- `source` 和 `destination`: `anywhere` - 这表示规则适用于从任何源地址到任何目的地址的数据包。
- `MARK or 0x4000`: 这是规则的具体操作，它将数据包的标记与 `0x4000` 进行“或”（OR）操作。这意味着如果数据包的标记中没有设置 `0x4000` 这一位，此操作会将其设置上。

在 Kubernetes 环境中，`KUBE-MARK-MASQ` 链通常用于标记那些需要进行源地址转换的数据包。这主要用于以下两种情况：

1. **Pod到外部的通信**：当一个 Pod 需要与集群外部的系统通信时，通常需要将其源 IP 地址改写为节点的 IP 地址，以便外部系统可以正确地回应。这种情况下，需要进行 SNAT。

2. **节点端口服务**：当外部流量通过节点端口访问集群内服务时，返回流量可能需要 SNAT 来保证正确路由回源地址。

通过设置 `0x4000` 标记，`iptables` 能够识别哪些数据包需要进行源地址转换。这样，当数据包离开节点时，`MASQUERADE` 规则（或类似的 SNAT 规则）就会将这些数据包的源 IP 地址更改为节点的 IP 地址，从而确保流量的连续性和正确路由。

#iptables -A KUBE-MARK-MASQ -j MARK --or-mark 0x4000
```

```bash
Chain KUBE-SEP-IOFPLAXKEZM6KDRU (1 references)
target     prot opt source               destination
KUBE-MARK-MASQ  all  --  10.244.1.184         anywhere             /* jupyter/wuyingwen-pod-external:http2 */
DNAT       tcp  --  anywhere             anywhere             /* jupyter/wuyingwen-pod-external:http2 */ tcp to:10.244.1.184:10352


这些 `iptables` 规则位于名为 `KUBE-SEP-Y74DMOLU7A4ANSVK` 的链中，这种链通常是 Kubernetes 服务定义的一部分，用于处理特定服务的流量。我们可以逐行解释这些规则的具体作用：

1. **`KUBE-MARK-MASQ` 规则**:
   - `target`: `KUBE-MARK-MASQ`
   - `prot opt`: 适用于所有协议（`all`）
   - `source`: 来自特定 IP 地址 `10.244.1.184`
   - `destination`: 适用于任何目的地址（`anywhere`）
   - `/* jupyter/wuyingwen-pod-external:http2 */`: 这是一个注释，表明规则与名为 `wuyingwen-pod-external` 的 Jupyter 服务相关，协议为 `http2`。

   这条规则用于标记从 `10.244.1.184`（可能是一个 Pod 的 IP）发出的流量，使得其在返回时可以进行源地址转换（SNAT）。这在 Kubernetes 中常用于确保流量在跨越不同网络时保持正确的源地址。

2. **`DNAT` 规则**:
   - `target`: `DNAT`
   - `prot opt`: 适用于 TCP 协议
   - `source`: 适用于从任何源地址（`anywhere`）
   - `destination`: 适用于任何目的地址（`anywhere`）
   - `/* jupyter/wuyingwen-pod-external:http2 */`: 同上，注释说明规则用途
   - `tcp to:10.244.1.184:10352`: 表示将匹配的流量的目的地进行网络地址转换（DNAT），将其重定向到 IP 地址 `10.244.1.184` 的 `10352` 端口。

   这条规则用于将流量重定向到特定的 Pod。在这个例子中，流量被重定向到运行 Jupyter 服务的 Pod 上，端口为 `10352`。

综合来看，这些规则的作用是捕获到特定服务（在这种情况下是一个 Jupyter 服务）的流量，并确保它被正确地路由到集群内的目标 Pod。这是 Kubernetes 服务发现和负载均衡机制的一部分，确保外部请求可以正确地被发送到集群内部的服务。
```

```bash
KUBE-SVC-K7NHKQJMVAP2IJBN  tcp  --  anywhere             10.1.81.211          /* jupyter/wuyingwen-pod-external:http2 cluster IP */ tcp dpt:10352
KUBE-SVC-K7NHKQJMVAP2IJBN  tcp  --  anywhere             tgq204               /* jupyter/wuyingwen-pod-external:http2 external IP */ tcp dpt:10352


这两条`iptables`规则位于Kubernetes环境中，是由`kube-proxy`组件管理的，用于处理到达特定Kubernetes服务的流量。这些规则是服务路由的一部分，具体解释如下：

1. **第一条规则**：
   - `KUBE-SVC-K7NHKQJMVAP2IJBN tcp -- anywhere 10.1.81.211 /* jupyter/wuyingwen-pod-external:http2 cluster IP */ tcp dpt:10352`
   - 解释：此规则适用于目的地是`10.1.81.211`（集群内部IP）的TCP流量，其中目的端口为10352。当满足这些条件时，流量将被重定向到`KUBE-SVC-K7NHKQJMVAP2IJBN`链。这通常意味着流量是针对特定的Kubernetes服务（在此例中是`jupyter/wuyingwen-pod-external`服务的HTTP2端口），并且使用了该服务的集群内部IP地址。

2. **第二条规则**：
   - `KUBE-SVC-K7NHKQJMVAP2IJBN tcp -- anywhere tgq204 /* jupyter/wuyingwen-pod-external:http2 external IP */ tcp dpt:10352`
   - 解释：此规则适用于目的地是`tgq204`（可能是一个外部IP或另一个网络别名）的TCP流量，其中目的端口同样为10352。当满足这些条件时，流量同样被重定向到`KUBE-SVC-K7NHKQJMVAP2IJBN`链。这表明流量是针对同一个Kubernetes服务的，但这次使用的是它的外部IP地址。

总体而言，这两条规则表明Kubernetes服务`jupyter/wuyingwen-pod-external`可以通过内部集群IP（`10.1.81.211`）和外部IP（`tgq204`）来访问，且服务都监听在TCP端口10352上。这种配置允许来自集群内部和外部的流量都能访问同一个服务，但通过不同的IP地址。`KUBE-SVC-K7NHKQJMVAP2IJBN`链可能包含了进一步的路由规则，比如负载均衡到多个Pod副本。
```



以wuyingwen的http0为例，讲解iptables过滤转发包过程

```bash
#1.包进入
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination
KUBE-SERVICES  all  --  anywhere             anywhere             /* kubernetes service portals */
DOCKER     all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL

#2.进入KUBE-SERVICES 
KUBE-SVC-KZQDQXK64KUAT7DG  tcp  --  anywhere             10.1.140.170         /* jupyter/wuyingwen-pod:http0 cluster IP */ tcp dpt:hbci

KUBE-SVC-X42XGK33M2VVDL7D  tcp  --  anywhere             10.1.81.211          /* jupyter/wuyingwen-pod-external:http0 cluster IP */ tcp dpt:10350
KUBE-SVC-X42XGK33M2VVDL7D  tcp  --  anywhere             tgq204               /* jupyter/wuyingwen-pod-external:http0 external IP */ tcp dpt:10350

#3.进入 KUBE-SVC-KZQDQXK64KUAT7DG 
Chain KUBE-SVC-KZQDQXK64KUAT7DG (1 references)
target     prot opt source               destination
KUBE-MARK-MASQ  tcp  -- !10.244.0.0/16        10.1.140.170         /* jupyter/wuyingwen-pod:http0 cluster IP */ tcp dpt:hbci
KUBE-SEP-XOR2I6ZI4DA326KG  all  --  anywhere             anywhere             /* jupyter/wuyingwen-pod:http0 */




#3.KUBE-SVC-X42XGK33M2VVDL7D
Chain KUBE-SVC-X42XGK33M2VVDL7D (2 references)
target     prot opt source               destination
KUBE-MARK-MASQ  tcp  -- !10.244.0.0/16        10.1.81.211          /* jupyter/wuyingwen-pod-external:http0 cluster IP */ tcp dpt:10350
KUBE-MARK-MASQ  tcp  -- !10.244.0.0/16        tgq204               /* jupyter/wuyingwen-pod-external:http0 external IP */ tcp dpt:10350
KUBE-SEP-SBSUFHYVFYNS4R7C  all  --  anywhere             anywhere             /* jupyter/wuyingwen-pod-external:http0 */


#4.KUBE-MARK-MASQ
Chain KUBE-MARK-MASQ (87 references)
target     prot opt source               destination
MARK       all  --  anywhere             anywhere             MARK or 0x4000


#5 KUBE-SEP-XOR2I6ZI4DA326KG
Chain KUBE-SEP-XOR2I6ZI4DA326KG (1 references)
target     prot opt source               destination
KUBE-MARK-MASQ  all  --  10.244.1.184         anywhere             /* jupyter/wuyingwen-pod:http0 */
DNAT       tcp  --  anywhere             anywhere             /* jupyter/wuyingwen-pod:http0 */ tcp to:10.244.1.184:3000


#5. KUBE-SEP-SBSUFHYVFYNS4R7C 
Chain KUBE-SEP-SBSUFHYVFYNS4R7C (1 references)
target     prot opt source               destination
KUBE-MARK-MASQ  all  --  10.244.1.184         anywhere             /* jupyter/wuyingwen-pod-external:http0 */
DNAT       tcp  --  anywhere             anywhere             /* jupyter/wuyingwen-pod-external:http0 */ tcp to:10.244.1.184:3000

```

这些`iptables`规则描述了Kubernetes中服务网络流量的处理过程。流量首先通过`PREROUTING`链进入系统，然后根据目的地地址被路由到相应的服务链，最后通过一系列的跳转和标记操作，被转发到最终的Pod IP和端口。以下是详细的流程和每个步骤的作用：

**流程和作用**

1. **进入PREROUTING链**：
   - 所有进入的包首先进入`PREROUTING`链。
   - 如果目的地是本地地址（`ADDRTYPE match dst-type LOCAL`），则流量被路由到`DOCKER`链。
   - 否则，流量被路由到`KUBE-SERVICES`链，用于处理Kubernetes服务相关的流量。

2. **在KUBE-SERVICES链中进行匹配**：
   - 根据目的IP和端口，流量被重定向到相应的服务链（例如`KUBE-SVC-KZQDQXK64KUAT7DG`或`KUBE-SVC-X42XGK33M2VVDL7D`）。

3. **在KUBE-SVC-*链中的处理**：
   - `KUBE-MARK-MASQ`规则为来自Pod子网外部的流量设置标记，准备进行源地址伪装（MASQUERADE）。
   - 流量被路由到特定的服务端点链（如`KUBE-SEP-XOR2I6ZI4DA326KG`或`KUBE-SEP-SBSUFHYVFYNS4R7C`）。

4. **在KUBE-MARK-MASQ链中的标记操作**：
   - 为流量设置特殊标记（`MARK or 0x4000`），这用于后续的源地址伪装。

5. **在KUBE-SEP-*链中的最终目的地决定**：
   - `KUBE-MARK-MASQ`为特定的Pod IP设置额外的标记。
   - `DNAT`规则将流量的目的地地址和端口转换为实际的Pod IP和端口（如`10.244.1.184:3000`）。

**流程图**

```SAS
[包进入]
     |
     v
[PREROUTING] -- (如果目的地是本地) --> [DOCKER]
     |
     v
[KUBE-SERVICES] -- (根据服务IP和端口) --> [KUBE-SVC-*]
     |
     v
[KUBE-SVC-*] -- (设置标记，选择端点) --> [KUBE-MARK-MASQ] -- [KUBE-SEP-*]
     |
     v
[KUBE-SEP-*] -- (执行DNAT，转发到Pod)
```

![](network/iptables04.png)

**当进入dnat后，数据包如何进入的pod内部？**

当`iptables`规则通过DNAT将流量的目的地修改为Pod的IP（例如`10.244.1.184:3000`）之后，数据包的发送到Pod内部的过程涉及Kubernetes的网络层和底层操作系统的网络堆栈。这个过程可以大致分解为以下步骤：

1. DNAT转换

- DNAT操作修改了数据包的目的IP和端口，将其从原始的集群IP和端口（如一个服务的ClusterIP）转换为实际Pod的IP和端口（`10.244.1.184:3000`）。

2. 路由决策

- 一旦DNAT完成，操作系统的路由表用于决定如何发送这个已修改的数据包。因为目的IP现在是Pod的IP，路由表将指示数据包通过与该Pod关联的网络接口发送。

3. 网络接口和CNI

- 在Kubernetes中，Pod网络通常由CNI（容器网络接口）插件管理。这些插件配置了每个节点上的网络，包括如何路由到每个Pod的流量。
- CNI插件创建了一个虚拟网络接口（比如veth pair），这个接口连接了Pod和宿主机的网络命名空间。

4. 到达Pod网络命名空间

- 数据包通过宿主机的网络堆栈，进入与Pod关联的虚拟网络接口。
- 从宿主机的网络命名空间，数据包被转发到Pod的网络命名空间。

5. Pod内部处理

- 一旦数据包到达Pod的网络命名空间，它会被Pod内部运行的应用程序接收。在这个例子中，监听在端口3000上的应用程序会处理这个数据包。

6. 应用程序响应

- 应用程序处理接收到的数据包，并可能产生响应。响应数据包会通过相同的网络路径返回给原始发送者，但是在发送前会经过源地址转换（SNAT），以确保响应能夠回到正确的源地址。









#### 几个常用命令

```bash
#用来查看所有的bridge 和与bridge相连接的veth
[root@tgq205 ~]# brctl show
bridge name     bridge id               STP enabled     interfaces
cni0            8000.9652de6b60b3       no              veth0fccc29b
                                                        veth1eb2e7ad
                                                        veth2399fb7c
                                                        veth2f4bf872
                                                        veth5f05b485
                                                        veth6ef22d85
                                                        vethb57e0ef7
                                                        vethbf16690b
                                                        vethf8f10afb
docker0         8000.0242f5ca3ed3       no
```











































